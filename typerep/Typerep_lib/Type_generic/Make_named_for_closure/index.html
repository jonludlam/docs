<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Make_named_for_closure (typerep.Typerep_lib.Type_generic.Make_named_for_closure)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">typerep</a> &#x00BB; <a href="../../index.html">Typerep_lib</a> &#x00BB; <a href="../index.html">Type_generic</a> &#x00BB; Make_named_for_closure</nav><header><h1>Module <code>Type_generic.Make_named_for_closure</code></h1><aside><p>Not all computations are arrow types. For example:</p><p><code>'a computation = Type_hash.t</code></p><p>However, arrow types computation such as <code>of_sexp</code>, <code>sexp_of</code>, <code>json_of</code>, etc. are such a standard case that is seems reasonable to share this extra layer of functor for it to build the <code>Named</code> module.</p></aside><h3 id="parameters"><a href="#parameters" class="anchor"></a>Parameters</h3><div class="spec parameter" id="argument-1-X" class="anchored"><a href="#argument-1-X" class="anchor"></a><code><span class="keyword">module</span> <a href="argument-1-X/index.html">X</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><h3 id="signature"><a href="#signature" class="anchor"></a>Signature</h3></header><div class="content"><div class="spec module" id="module-Context" class="anchored"><a href="#module-Context" class="anchor"></a><code><span class="keyword">module</span> <a href="Context/index.html">Context</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></div><div><p>Work in progress representation of a computation. This is mostly used to handle recursive types. While building a computation on a recursive type, one needs to have some computation available for the location where the type appears recursively. <code>init</code> will be called once on each new type_name met during the traversal of a type. Each time the same type is encountered again, <code>get_wip_computation</code> will be called. At the end of the traversal of that particular type, <code>set_final_computation</code> will be called, offering as a way to &quot;close&quot; the wip representation. <code>'a t</code> can be mutable (and is likely to be in practice).</p><p>After a <code>set_final_computation</code> is performed and return a final computation C for a type_name, C will be memoized and returned for each further occurrences of the same type_name inside the typerep, going further on.</p></div></div><div class="spec value" id="val-init" class="anchored"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : <a href="Context/index.html#type-t">Context.t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../Typename/index.html#type-t">Typename.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div class="spec value" id="val-get_wip_computation" class="anchored"><a href="#val-get_wip_computation" class="anchor"></a><code><span class="keyword">val</span> get_wip_computation : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="argument-1-X/index.html#type-t">X.t</a></span></code></div><div class="spec value" id="val-set_final_computation" class="anchored"><a href="#val-set_final_computation" class="anchor"></a><code><span class="keyword">val</span> set_final_computation : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="argument-1-X/index.html#type-t">X.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="argument-1-X/index.html#type-t">X.t</a></span></code></div><div><div class="spec value" id="val-share" class="anchored"><a href="#val-share" class="anchor"></a><code><span class="keyword">val</span> share : <span><span class="type-var">_</span> <a href="../../Std_internal/Typerep/index.html#type-t">Std_internal.Typerep.t</a></span> <span>&#45;&gt;</span> bool</code></div><div><p>It might be interesting to inline some computation for a few typerep if they appear several times within a typerep. This parameters will allow one to tweak the sharing between multiple occurences of the same typename. <code>share = true</code> means no inlining.</p><p>Note that not sharing recursive types will lead the <code>of_typerep</code> function to loop forever. Be careful when setting this.</p><p>An example where it is not suitable to share everything for example is typestruct. The typestruct of an int is a simple constructor called <code>Int</code>, naming it once and using the name to refere to it later within the typestruct does not lead to a shorter typestruct, and is in fact less readable. The benefit of the sharing depends on the computation, its memory and building costs.</p></div></div></div></body></html>