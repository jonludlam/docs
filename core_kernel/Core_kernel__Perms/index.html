<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Core_kernel__Perms (core_kernel.Core_kernel__Perms)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">core_kernel</a> &#x00BB; Core_kernel__Perms</nav><header><h1>Module <code>Core_kernel__Perms</code></h1><p>These types are intended to be used as phantom types encoding the permissions on a given type.</p><h3 id="basic-usage"><a href="#basic-usage" class="anchor"></a>Basic Usage</h3><p>Here's a hypothetical interface to an on-off switch which uses them:</p><pre><code>open Perms.Export

module Switch : sig
  type -'permissions t

  val create : unit -&gt; [&lt; _ perms] t
  val read  : [&gt; read] t  -&gt; [`On | `Off]
  val write : [&gt; write] t -&gt; [`On | `Off] -&gt; unit
end</code></pre><p>Note that the permissions parameter must be contravariant -- you are allowed to forget that you have any particular permissions, but not give yourself new permissions.</p><p>You can now create different &quot;views&quot; of a switch. For example, in:</p><pre><code>let read_write_s1 : read_write Switch.t = Switch.create ()
let read_only_s1 = (read_write_s1 :&gt; read t)</code></pre><p><code>read_write_s1</code> and <code>read_only_s1</code> are physically equal, but calling <code>Switch.write read_only_s1</code> is a type error, while <code>Switch.write read_write_s1</code> is allowed.</p><p>Also note that this is a type error:</p><pre><code>let s1 = Switch.create ()
let read_write_s1 = (s1 :&gt; read_write t)
let immutable_s1  = (s1 :&gt; immutable  t)</code></pre><p>which is good, since it would be incorrect if it were allowed. This is enforced by:</p><p>1. Having the permissions parameter be contravariant and the only way to create a <code>t</code> be a function call. This causes the compiler to require that created <code>t</code>s have a concrete type (due to the value restriction).</p><p>2. Ensuring that there is no type that has both <code>read_write</code> and <code>immutable</code> as subtypes. This is why the variants are <code>`Who_can_write of Me.t</code> and <code>`Who_can_write
    of Nobody.t</code> rather than <code>`I_can_write</code> and <code>`Nobody_can_write</code>.</p><p>Note that, as a consequence of 1, exposing a global switch as in:</p><pre><code>module Switch : sig
  ...
  val global : [&lt; _ perms] t
end</code></pre><p>would be a mistake, since one library could annotate <code>Switch.global</code> as an <code>immutable Switch.t</code>, while another library writes to it.</p><h3 id="more-usage-patterns"><a href="#more-usage-patterns" class="anchor"></a>More Usage Patterns</h3><p>The standard usage pattern is as above:</p><ul><li>The permissions type parameter is contravariant with no constraints.</li><li>The result of creation functions is a <code>t</code> with <code>[&lt; _ perms]</code> permissions.</li><li>Functions which take a <code>t</code> and access it in some way represent that access in the type.</li></ul><p>The reason for having creation functions return a <code>t</code> with <code>[&lt; _ perms]</code> permissions is to help give early warning if you create a <code>t</code> with a nonsensical permission type that you wouldn't be able to use with the other functions in the module.</p><p>Ideally, this would be done with a constraint on the type in a usage pattern like this:</p><ul><li>The permissions type parameter is contravariant with constraint <code>[&lt; _ perms]</code>.</li><li>The result of creation functions is a <code>t</code> with no constraint on the permissions.</li><li>Functions which take a <code>t</code> and access it in some way represent that access in the type.</li></ul><p>Unfortunately, that doesn't work for us due to some quirks in the way constraints of this form are handled: In particular, they don't work well with <code>[@@deriving sexp]</code> and they don't work well with included signatures. But you could try this usage pattern if you don't do either of those things.</p><p>For some types you may expect to always have read permissions, and it may therefore by annoying to keep rewriting <code>[&gt; read]</code>. In that case you may want to try this usage pattern:</p><ul><li>The permissions type parameter is contravariant with constraint <code>[&gt; read]</code>.</li><li>The result of creation functions is a <code>t</code> with <code>[&lt; _ perms]</code> permissions.</li><li>Functions which take a <code>t</code> and access it in some way represent that access in the type, except that you don't have to specify read permissions.</li></ul><p>However, the standard usage pattern is again preferred to this one: <code>constraint</code> has lots of sharp edges, and putting <code>[&gt; read]</code> instead of <code>_</code> in the types provides explicitness.</p></header><div class="content"></div></body></html>