<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Core_kernel__Type_immediacy (core_kernel.Core_kernel__Type_immediacy)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">core_kernel</a> &#x00BB; Core_kernel__Type_immediacy</nav><header><h1>Module <code>Core_kernel__Type_immediacy</code></h1><p>Witnesses that express whether a type's values are always, sometimes, or never immediate.</p><p>A value is immediate when it is internally represented unboxed, using one word of memory rather than a pointer to a heap-allocated block.</p><p>Some examples:</p><ul><li>All <code>int</code> values are by definition immediate, i.e., unboxed, and so <code>int</code> is always immediate.</li></ul><ul><li>A <code>'a list</code> is either <code>[]</code>, which is internally represented as 0 (immediate), or a non-empty list, which is represented as a pointer to a heap block (boxed), which contains the first element and the pointer to the rest of the list. Therefore <code>'a
      list</code> is sometimes immediate.</li></ul><ul><li>All values of type <code>'a ref</code> are represented as a pointer to a heap block containing the actual values <code>'a</code>. Therefore <code>'a ref</code> is never immediate.</li></ul><p>The witness values can be used to perform safe optimizations such as allowing a more efficient <code>'a array</code> blit operations if <code>'a</code> is always immediate. These witnesses can also be used to perform safe conversions between immediate values of type <code>'a</code> and <code>int</code> instead of using <code>Obj.magic</code>.</p><h3 id="converting-between-values-and-ints"><a href="#converting-between-values-and-ints" class="anchor"></a>Converting between values and ints</h3><p>Consider an arbitrary type <code>'a</code> for which you have built a type-immediacy witness using this interface. Let's call it <code>w : 'a t</code>.</p><p>You can use the two following functions and <code>w</code> to cast back and forth values from the type <code>'a</code> to the type <code>int</code>:</p><pre><code>val int_as_value : 'a t -&gt; int -&gt; 'a option
val value_as_int : 'a t -&gt; 'a  -&gt; int option</code></pre><p>For the rest of this section, we will assume <code>int_as_value</code> and <code>value_as_int</code> partially applied to <code>w</code>.</p><p>Consider the following cases:</p><ul><li><p>let <code>v</code> be an immediate value.</p><p>Let <code>i</code> be the <code>int</code> that internally represents <code>v</code>. Then, <code>value_as_int v</code> returns <code>Some i</code>.</p><p>We can also recover <code>v</code> by using the conversions that go the other way. In particular, <code>int_as_value i</code> returns <code>Some v</code>.</p></li></ul><ul><li><p>let <code>v</code> be a boxed value that cannot be converted to an <code>int</code>.</p><p><code>value_as_int v</code> returns <code>None</code> because there does not exist an int s.t. <code>int_as_value
    i</code> evaluates to <code>Some v</code>.</p></li></ul><ul><li><p>let <code>i</code> be an int that does not represent any value of type <code>'a</code></p><p><code>int_as_value i</code> returns <code>None</code>.</p></li></ul><h3 id="faster-*_exn-functions-and-functions-with-boolean-results"><a href="#faster-*_exn-functions-and-functions-with-boolean-results" class="anchor"></a>Faster *_exn functions and functions with boolean results</h3><p><code>value_is_int v</code> is a faster equivalent to <code>Option.is_some   (value_as_int v)</code>. <code>value_as_int_exn v</code> is a faster equivalent to <code>Option.value_exn (value_as_int v)</code>.</p><p><code>int_is_value i</code> is a faster equivalent to <code>Option.is_some   (int_as_value i)</code>. <code>int_as_value_exn i</code> is a faster equivalent to <code>Option.value_exn (int_as_value i)</code>.</p><p>These are lightweight functions that avoid allocating the option. <code>value_is_int</code> (resp <code>int_is_value</code>) can be used with <code>value_as_int_exn</code> (resp <code>int_as_value_exn</code>) to avoid both allocation or using a <code>try with</code> statement, paying only some small amount of CPU time for calling <code>value_is_int</code> (resp <code>int_is_value</code>):</p><pre><code>match value_as_int v with
| Some v -&gt; some v
| None -&gt; none</code></pre><p>VS</p><pre><code>if value_is_int v
then some (value_as_int_exn v)
else none</code></pre><h3 id="example"><a href="#example" class="anchor"></a>Example</h3><p>Consider the following type:</p><pre><code>type test =
  | A
  | B
  | C of int
with typerep</code></pre><p>Type <code>test</code> is sometimes immediate, as <code>A</code> is represented as <code>0</code>, <code>B</code> as <code>1</code>, and <code>C</code> is a boxed value. We can construct a witness of type <code>test Sometimes.t</code> by using <code>Sometimes.of_typerep</code> or <code>of_typerep</code> and extracting the witness. Let's call the witness <code>w</code> here. We can now use it to safely convert between values of <code>test</code> and <code>int</code>:</p><p><code>Sometimes.value_as_int w A</code> evaluates to <code>Some 0</code> <code>Sometimes.value_as_int w B</code> evaluates to <code>Some 1</code> <code>Sometimes.value_as_int w (C 1)</code> evaluates to <code>None</code></p><p><code>Sometimes.int_as_value w 0</code> evaluates to <code>Some A</code> <code>Sometimes.int_as_value w 1</code> evaluates to <code>Some B</code> <code>Sometimes.int_as_value w n</code> evaluates to <code>None</code> for all other values n</p><p>Consider this other example:</p><pre><code>type test = bool with typerep</code></pre><p>Type <code>test</code> is always immediate, since <code>true</code> is represented as <code>1</code> and <code>false</code> as <code>0</code>. We can construct a witness of type <code>test Always.t</code> by using <code>Always.of_typerep</code> or <code>of_typerep</code> and extracting the witness. Let's call the witness <code>w</code>:</p><p><code>Always.value_as_int w false</code> evaluates to <code>Some 0</code> <code>Always.value_as_int w true</code> evaluates to <code>Some 1</code></p><p><code>Always.value_as_int_exn w false</code> evaluates to <code>0</code> <code>Always.value_as_int_exn w true</code> evaluates to <code>1</code></p><p><code>Always.int_as_value w 0</code> evaluates to <code>Some false</code> <code>Always.int_as_value w 1</code> evaluates to <code>Some true</code> <code>Always.int_as_value w (-1)</code> evaluates to <code>None</code></p><p><code>Always.int_as_value_exn w 0</code> evaluates to <code>false</code> <code>Always.int_as_value_exn w 1</code> evaluates to <code>true</code> <code>Always.int_as_value_exn w (-1)</code> raises</p><h3 id="n-ary-types-that-are-immediate-independently-of-their-type-arguments"><a href="#n-ary-types-that-are-immediate-independently-of-their-type-arguments" class="anchor"></a>N-ary types that are immediate independently of their type arguments</h3><p>We also provide <code>For_all_parameters_S*</code> functors. Those are useful when one has a type with type parameters, but knows that values of that type will always be immediate (for example) no matter what the actual parameter is. They can use <code>Always.For_all_parameters_S*</code> to obtain access to a polymorphic witness.</p><p>An exception is raised on functor application if such witness cannot be obtained. That happens either because the witness depends on the actual type parameter, or because the type has a different witness (e.g. <code>Sometimes</code> instead of <code>Always</code>).</p></header><div class="content"></div></body></html>