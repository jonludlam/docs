<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S (git-http.Git_http.Sync.S)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> – <a href="../../../index.html">git-http</a> &#x00BB; <a href="../../index.html">Git_http</a> &#x00BB; <a href="../index.html">Sync</a> &#x00BB; S</nav><header><h1>Module type <code>Sync.S</code></h1></header><div class="content"><div class="spec module" id="module-Web" class="anchored"><a href="#module-Web" class="anchor"></a><code><span class="keyword">module</span> <a href="Web/index.html">Web</a> : <a href="../../Web/module-type-S/index.html">Web.S</a></code></div><div class="spec module" id="module-Client" class="anchored"><a href="#module-Client" class="anchor"></a><code><span class="keyword">module</span> <a href="Client/index.html">Client</a> : <a href="../module-type-CLIENT/index.html">CLIENT</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-CLIENT/index.html#type-headers">headers</a> = <a href="Web/HTTP/index.html#type-headers">Web.HTTP.headers</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-CLIENT/index.html#type-meth">meth</a> = <a href="Web/HTTP/index.html#type-meth">Web.HTTP.meth</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-CLIENT/index.html#type-resp">resp</a> = <a href="Web/index.html#type-resp">Web.resp</a></code></div><div class="spec module" id="module-Endpoint" class="anchored"><a href="#module-Endpoint" class="anchor"></a><code><span class="keyword">module</span> <a href="Endpoint/index.html">Endpoint</a> : <a href="../module-type-ENDPOINT/index.html">ENDPOINT</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../module-type-ENDPOINT/index.html#type-t">t</a> = <a href="Client/index.html#type-endpoint">Client.endpoint</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../module-type-ENDPOINT/index.html#type-headers">headers</a> = <a href="Client/index.html#type-headers">Client.headers</a></code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../../git/Git/Sync/module-type-S/index.html">Git.Sync.S</a> <span class="keyword">with</span> <span class="keyword">module</span> <a href="../../../../git/Git/Sync/module-type-S/Endpoint/index.html">Endpoint</a> := <a href="Endpoint/index.html">Endpoint</a></code></span></summary><div class="spec module" id="module-Store" class="anchored"><a href="#module-Store" class="anchor"></a><code><span class="keyword">module</span> <a href="Store/index.html">Store</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec type" id="type-error" class="anchored"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error</code></div><div><div class="spec value" id="val-pp_error" class="anchored"><a href="#val-pp_error" class="anchor"></a><code><span class="keyword">val</span> pp_error : <span><a href="index.html#type-error">error</a> <a href="../../../../fmt/Fmt/index.html#type-t">Fmt.t</a></span></code></div><div><p>Pretty-printer of <a href="index.html#type-error"><code>error</code></a>.</p></div></div><div><div class="spec type" id="type-command" class="anchored"><a href="#type-command" class="anchor"></a><code><span class="keyword">type</span> command = [ </code><table><tr id="type-command.Create" class="anchored"><td class="def constructor"><a href="#type-command.Create" class="anchor"></a><code>| </code><code>`Create <span class="keyword">of</span> <a href="Store/Hash/index.html#type-t">Store.Hash.t</a> * <a href="Store/Reference/index.html#type-t">Store.Reference.t</a></code></td><td class="doc"><p>To create a new reference on the server.</p></td></tr><tr id="type-command.Delete" class="anchored"><td class="def constructor"><a href="#type-command.Delete" class="anchor"></a><code>| </code><code>`Delete <span class="keyword">of</span> <a href="Store/Hash/index.html#type-t">Store.Hash.t</a> * <a href="Store/Reference/index.html#type-t">Store.Reference.t</a></code></td><td class="doc"><p>To delete an existing reference on the server - <code>`Delete_refs</code> needs to be available in both side as a <code>Capability</code>.t.</p></td></tr><tr id="type-command.Update" class="anchored"><td class="def constructor"><a href="#type-command.Update" class="anchor"></a><code>| </code><code>`Update <span class="keyword">of</span> <a href="Store/Hash/index.html#type-t">Store.Hash.t</a> * <a href="Store/Hash/index.html#type-t">Store.Hash.t</a> * <a href="Store/Reference/index.html#type-t">Store.Reference.t</a></code></td><td class="doc"><p>To update a reference from a commit hash to a new commit hash.</p></td></tr></table><code> ]</code></div><div><p>A push command to interact with the server.</p></div></div><div><div class="spec value" id="val-pp_command" class="anchored"><a href="#val-pp_command" class="anchor"></a><code><span class="keyword">val</span> pp_command : <span><a href="index.html#type-command">command</a> <a href="../../../../fmt/Fmt/index.html#type-t">Fmt.t</a></span></code></div><div><p>Pretty-printer of <a href="index.html#type-command"><code>command</code></a>.</p></div></div><div class="spec value" id="val-push" class="anchored"><a href="#val-push" class="anchor"></a><code><span class="keyword">val</span> push : <a href="Store/index.html#type-t">Store.t</a> <span>&#45;&gt;</span> <span>push:<span>(<span><span>(<a href="Store/Hash/index.html#type-t">Store.Hash.t</a> * <a href="Store/Reference/index.html#type-t">Store.Reference.t</a> * bool)</span> list</span> <span>&#45;&gt;</span> <span><span>(<span><a href="Store/Hash/index.html#type-t">Store.Hash.t</a> list</span> * <span><a href="index.html#type-command">command</a> list</span>)</span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;capabilities:<span><a href="../../../../git/Git/Capability/index.html#type-t">Git.Capability.t</a> list</span></span> <span>&#45;&gt;</span> <a href="Endpoint/index.html#type-t">Endpoint.t</a> <span>&#45;&gt;</span> <span><span><span>(<span><span><span>(<a href="Store/Reference/index.html#type-t">Store.Reference.t</a>, <a href="Store/Reference/index.html#type-t">Store.Reference.t</a> * string)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> list</span>, <a href="index.html#type-error">error</a>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></code></div><div class="spec value" id="val-ls" class="anchored"><a href="#val-ls" class="anchor"></a><code><span class="keyword">val</span> ls : <a href="Store/index.html#type-t">Store.t</a> <span>&#45;&gt;</span> <span>?&#8288;capabilities:<span><a href="../../../../git/Git/Capability/index.html#type-t">Git.Capability.t</a> list</span></span> <span>&#45;&gt;</span> <a href="Endpoint/index.html#type-t">Endpoint.t</a> <span>&#45;&gt;</span> <span><span><span>(<span><span>(<a href="Store/Hash/index.html#type-t">Store.Hash.t</a> * <a href="Store/Reference/index.html#type-t">Store.Reference.t</a> * bool)</span> list</span>, <a href="index.html#type-error">error</a>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></code></div><div class="spec value" id="val-fetch" class="anchored"><a href="#val-fetch" class="anchor"></a><code><span class="keyword">val</span> fetch : <a href="Store/index.html#type-t">Store.t</a> <span>&#45;&gt;</span> <span>?&#8288;shallow:<span><a href="Store/Hash/index.html#type-t">Store.Hash.t</a> list</span></span> <span>&#45;&gt;</span> <span>?&#8288;capabilities:<span><a href="../../../../git/Git/Capability/index.html#type-t">Git.Capability.t</a> list</span></span> <span>&#45;&gt;</span> <span>notify:<span>(<span><a href="Store/Hash/index.html#type-t">Store.Hash.t</a> <a href="../../../../git/Git/Sync/index.html#type-shallow_update">Git.Sync.shallow_update</a></span> <span>&#45;&gt;</span> <span>unit <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span></span> <span>&#45;&gt;</span> <span>negociate:<span>(<span>(<span><a href="Store/Hash/index.html#type-t">Store.Hash.t</a> <a href="../../../../git/Git/Sync/index.html#type-acks">Git.Sync.acks</a></span> <span>&#45;&gt;</span> <span class="type-var">'state</span> <span>&#45;&gt;</span> <span><span>(<span>[ `Ready <span>| `Done</span> <span><span>| `Again</span> of <a href="Store/Hash/Set/index.html#type-t">Store.Hash.Set.t</a></span> ]</span> * <span class="type-var">'state</span>)</span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> * <span class="type-var">'state</span>)</span></span> <span>&#45;&gt;</span> <span>have:<a href="Store/Hash/Set/index.html#type-t">Store.Hash.Set.t</a></span> <span>&#45;&gt;</span> <span>want:<span>(<span><span>(<a href="Store/Hash/index.html#type-t">Store.Hash.t</a> * <a href="Store/Reference/index.html#type-t">Store.Reference.t</a> * bool)</span> list</span> <span>&#45;&gt;</span> <span><span><span>(<a href="Store/Reference/index.html#type-t">Store.Reference.t</a> * <a href="Store/Hash/index.html#type-t">Store.Hash.t</a>)</span> list</span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;deepen:<span>[ <span>`Depth of int</span> <span><span>| `Timestamp</span> of int64</span> <span><span>| `Ref</span> of <a href="../../../../git/Git/Reference/index.html#type-t">Git.Reference.t</a></span> ]</span></span> <span>&#45;&gt;</span> <a href="Endpoint/index.html#type-t">Endpoint.t</a> <span>&#45;&gt;</span> <span><span><span>(<span><span>(<a href="Store/Reference/index.html#type-t">Store.Reference.t</a> * <a href="Store/Hash/index.html#type-t">Store.Hash.t</a>)</span> list</span> * int, <a href="index.html#type-error">error</a>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></code></div><div><div class="spec value" id="val-fetch_some" class="anchored"><a href="#val-fetch_some" class="anchor"></a><code><span class="keyword">val</span> fetch_some : <a href="Store/index.html#type-t">Store.t</a> <span>&#45;&gt;</span> <span>?&#8288;capabilities:<span><a href="../../../../git/Git/Capability/index.html#type-t">Git.Capability.t</a> list</span></span> <span>&#45;&gt;</span> <span>references:<span><span><a href="Store/Reference/index.html#type-t">Store.Reference.t</a> list</span> <a href="Store/Reference/Map/index.html#type-t">Store.Reference.Map.t</a></span></span> <span>&#45;&gt;</span> <a href="Endpoint/index.html#type-t">Endpoint.t</a> <span>&#45;&gt;</span> <span><span><span>(<span><a href="Store/Hash/index.html#type-t">Store.Hash.t</a> <a href="Store/Reference/Map/index.html#type-t">Store.Reference.Map.t</a></span> * <span><span><a href="Store/Reference/index.html#type-t">Store.Reference.t</a> list</span> <a href="Store/Reference/Map/index.html#type-t">Store.Reference.Map.t</a></span>, <a href="index.html#type-error">error</a>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></code></div><div><p><code>fetch_some git ?capabilities ~references repository</code> will fetch some remote references specified by <code>references</code>.</p><p><code>references</code> is a map which:</p><ul><li>the key is the <b>remote</b> reference.</li><li>the value is a list of <b>local</b> references - which may not exist yet.</li></ul><p>Then, the function will try to download all of these remote references and returns 2 maps:</p><ul><li><p>the first map contains all local references updated by the new hash. This new hash is come from the server as the downloaded remote reference asked by the client by <code>references</code>. Then, from associated local references with remote references, we updated them with the associated hash.</p><p>For example, if <code>references</code> is: </p><pre><code>{ &quot;refs/heads/master&quot;: [
&quot;refs/remotes/origin/master&quot; ; &quot;refs/heads/master&quot; ] } </code></pre><p>We will update (or create) &quot;refs/remotes/origin/master&quot; and &quot;refs/heads/master&quot; with the new hash downloaded from the remote reference &quot;refs/heads/master&quot; only if it's necessary (only if we did not find the hash referenced by &quot;refs/heads/master&quot; in the local store).</p></li><li><p>the second map is a <b>subset</b> of <code>references</code> which contains all binder of:</p><ul><li>remote references which does not exist on the server side.</li><li>remote references which references to an already existing in the local store hash.</li></ul></li></ul><p>The client should not put the same local reference as a value of some remote references. The client can define non-existing remote references (then, they appear on the second map). The client can want to set non-existing local references - we will create them.</p><p>If the processus encountered an error when it updates references, it leaves but, it did partially some update on some local references.</p></div></div><div><div class="spec value" id="val-fetch_all" class="anchored"><a href="#val-fetch_all" class="anchor"></a><code><span class="keyword">val</span> fetch_all : <a href="Store/index.html#type-t">Store.t</a> <span>&#45;&gt;</span> <span>?&#8288;capabilities:<span><a href="../../../../git/Git/Capability/index.html#type-t">Git.Capability.t</a> list</span></span> <span>&#45;&gt;</span> <span>references:<span><span><a href="Store/Reference/index.html#type-t">Store.Reference.t</a> list</span> <a href="Store/Reference/Map/index.html#type-t">Store.Reference.Map.t</a></span></span> <span>&#45;&gt;</span> <a href="Endpoint/index.html#type-t">Endpoint.t</a> <span>&#45;&gt;</span> <span><span><span>(<span><a href="Store/Hash/index.html#type-t">Store.Hash.t</a> <a href="Store/Reference/Map/index.html#type-t">Store.Reference.Map.t</a></span> * <span><span><a href="Store/Reference/index.html#type-t">Store.Reference.t</a> list</span> <a href="Store/Reference/Map/index.html#type-t">Store.Reference.Map.t</a></span> * <span><a href="Store/Hash/index.html#type-t">Store.Hash.t</a> <a href="Store/Reference/Map/index.html#type-t">Store.Reference.Map.t</a></span>, <a href="index.html#type-error">error</a>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></code></div><div><p><code>fetch_all git ?capabilities ~references repository</code> has the same semantic than <a href="index.html#val-fetch_some"><code>fetch_some</code></a> for any remote references found on <code>references</code>. However, <code>fetch all</code> will download all remote references available on the server (and whose hash is not available on the local store). If these remote references are not associated with some local references, we return a third map which contains these remote references binded with the new hash downloaded.</p><p>We <b>don't</b> notice any non-downloaded remote references not found on the <code>references</code> map and whose hash already exists on the local store.</p><p>Then, the client can bind these new hashes with specific local references or just give up.</p></div></div><div><div class="spec value" id="val-fetch_one" class="anchored"><a href="#val-fetch_one" class="anchor"></a><code><span class="keyword">val</span> fetch_one : <a href="Store/index.html#type-t">Store.t</a> <span>&#45;&gt;</span> <span>?&#8288;capabilities:<span><a href="../../../../git/Git/Capability/index.html#type-t">Git.Capability.t</a> list</span></span> <span>&#45;&gt;</span> <span>reference:<span>(<a href="Store/Reference/index.html#type-t">Store.Reference.t</a> * <span><a href="Store/Reference/index.html#type-t">Store.Reference.t</a> list</span>)</span></span> <span>&#45;&gt;</span> <a href="Endpoint/index.html#type-t">Endpoint.t</a> <span>&#45;&gt;</span> <span><span><span>(<span>[ `AlreadySync <span><span>| `Sync</span> of <span><a href="Store/Hash/index.html#type-t">Store.Hash.t</a> <a href="Store/Reference/Map/index.html#type-t">Store.Reference.Map.t</a></span></span> ]</span>, <a href="index.html#type-error">error</a>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></code></div><div><p><code>fetch_one git ?capabilities ~reference repository</code> is a specific call of <a href="index.html#val-fetch_some"><code>fetch_some</code></a> with only one reference. Then, it retuns:</p><ul><li><code>`AlreadySync</code> if the hash of the requested reference already exists on the local store</li><li><code>`Sync updated</code> if we downloaded <code>new_hash</code> and set <code>local_ref</code> with this new hash.</li></ul></div></div><div class="spec value" id="val-pp_fetch_one" class="anchored"><a href="#val-pp_fetch_one" class="anchor"></a><code><span class="keyword">val</span> pp_fetch_one : <span><span>[ `AlreadySync <span><span>| `Sync</span> of <span><a href="Store/Hash/index.html#type-t">Store.Hash.t</a> <a href="Store/Reference/Map/index.html#type-t">Store.Reference.Map.t</a></span></span> ]</span> <a href="../../../../fmt/Fmt/index.html#type-t">Fmt.t</a></span></code></div><div class="spec value" id="val-clone" class="anchored"><a href="#val-clone" class="anchor"></a><code><span class="keyword">val</span> clone : <a href="Store/index.html#type-t">Store.t</a> <span>&#45;&gt;</span> <span>?&#8288;capabilities:<span><a href="../../../../git/Git/Capability/index.html#type-t">Git.Capability.t</a> list</span></span> <span>&#45;&gt;</span> <span>reference:<span>(<a href="Store/Reference/index.html#type-t">Store.Reference.t</a> * <a href="Store/Reference/index.html#type-t">Store.Reference.t</a>)</span></span> <span>&#45;&gt;</span> <a href="Endpoint/index.html#type-t">Endpoint.t</a> <span>&#45;&gt;</span> <span><span><span>(unit, <a href="index.html#type-error">error</a>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></code></div><div><div class="spec value" id="val-update_and_create" class="anchored"><a href="#val-update_and_create" class="anchor"></a><code><span class="keyword">val</span> update_and_create : <a href="Store/index.html#type-t">Store.t</a> <span>&#45;&gt;</span> <span>?&#8288;capabilities:<span><a href="../../../../git/Git/Capability/index.html#type-t">Git.Capability.t</a> list</span></span> <span>&#45;&gt;</span> <span>references:<span><span><a href="Store/Reference/index.html#type-t">Store.Reference.t</a> list</span> <a href="Store/Reference/Map/index.html#type-t">Store.Reference.Map.t</a></span></span> <span>&#45;&gt;</span> <a href="Endpoint/index.html#type-t">Endpoint.t</a> <span>&#45;&gt;</span> <span><span><span>(<span><span><span>(<a href="Store/Reference/index.html#type-t">Store.Reference.t</a>, <a href="Store/Reference/index.html#type-t">Store.Reference.t</a> * string)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> list</span>, <a href="index.html#type-error">error</a>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></code></div><div><p>As <a href="index.html#val-fetch_some"><code>fetch_some</code></a>, <code>update git ?capabilities ~references repository</code> is the other side of the communication with a Git server and update and create remote references when it uploads local hashes.</p><p><code>reference</code> is a map which:</p><ul><li>the key is the <b>local</b> reference.</li><li>the value is a list of <b>remote</b> references - which may not exist yet.</li></ul><p>Then, the function will try to upload all of these local references to the binded remote references. If binded remote reference does not exist on the server, we ask to the server to create and set it to the local hash.</p><p>For each update action, we check if the local store has the remote hash. In other case, we miss this action - that means, the local store is not synchronized with the server (and the client probably needs to <a href="index.html#val-fetch_some"><code>fetch_some</code></a> before).</p><p>Then, it returns a list of results. The <code>Ok</code> case with the remote reference which the server updated correctly and the <code>Error</code> case with the remote reference which the server encountered an error with a description of this error.</p><p>At this final stage, the function does not encountered any error during the commmunication - if it's the case, we did not do any modification on the server and return an <a href="index.html#type-error"><code>error</code></a>.</p></div></div><div class="spec value" id="val-pp_update_and_create" class="anchored"><a href="#val-pp_update_and_create" class="anchor"></a><code><span class="keyword">val</span> pp_update_and_create : <span><span><span><span>(<a href="Store/Reference/index.html#type-t">Store.Reference.t</a>, <a href="Store/Reference/index.html#type-t">Store.Reference.t</a> * string)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> list</span> <a href="../../../../fmt/Fmt/index.html#type-t">Fmt.t</a></span></code></div></details></div></div></div></div></body></html>