<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Async_unix__Writer (async_unix.Async_unix__Writer)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">async_unix</a> &#x00BB; Async_unix__Writer</nav><header><h1>Module <code>Async_unix__Writer</code></h1><p><code>Writer</code> is Async's main API for output to a file descriptor. It is the analog of <code>Core.Out_channel</code>.</p><p>Each writer has an internal buffer, to which <code>Writer.write*</code> adds data. Each writer uses an Async cooperative thread that makes <code>write()</code> system calls to move the data from the writer's buffer to an OS buffer via the file descriptor.</p><p>There is no guarantee that the data sync on the other side of the writer can keep up with the rate at which you are writing. If it cannot, the OS buffer will fill up and the writer's cooperative thread will be unable to send any bytes. In that case, calls to <code>Writer.write*</code> will grow the writer's buffer without bound, as long as your program produces data. One solution to this problem is to call <code>Writer.flushed</code> and not continue until that becomes determined, which will only happen once the bytes in the writer's buffer have been successfully transferred to the OS buffer. Another solution is to check <code>Writer.bytes_to_write</code> and not produce any more data if that is beyond some bound.</p><p>There are two kinds of errors that one can handle with writers. First, a writer can be <code>close</code>d, which will cause future <code>write</code>s (and other operations) to synchronously raise an exception. Second, the writer's cooperative thread can fail due to a <code>write()</code> system call failing. This will cause an exception to be sent to the writer's monitor, which will be a child of the monitor in effect when the writer is created. One can deal with such asynchronous exceptions in the usual way, by handling the stream returned by <code>Monitor.detach_and_get_error_stream (Writer.monitor writer)</code>.</p></header><div class="content"></div></body></html>