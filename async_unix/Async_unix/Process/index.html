<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Process (async_unix.Async_unix.Process)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_unix</a> &#x00BB; <a href="../index.html">Async_unix</a> &#x00BB; Process</nav><header><h1>Module <code>Async_unix.Process</code></h1><p><code>Async.Process</code> is for creating child processes of the current process, and communicating with children via their stdin, stdout, and stderr. <code>Async.Process</code> is the Async analog of <code>Core.Unix.create_process</code> and related functions.</p></header><div class="content"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></div><div><div class="spec include"><div class="doc"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></div></div></div></div><div><div class="spec value" id="val-pid" class="anchored"><a href="#val-pid" class="anchor"></a><code><span class="keyword">val</span> pid : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Pid/index.html#type-t">Core.Pid.t</a></code></div><div><p>accessors</p></div></div><div class="spec value" id="val-stdin" class="anchored"><a href="#val-stdin" class="anchor"></a><code><span class="keyword">val</span> stdin : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Writer/index.html#type-t">Writer.t</a></code></div><div class="spec value" id="val-stdout" class="anchored"><a href="#val-stdout" class="anchor"></a><code><span class="keyword">val</span> stdout : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Reader/index.html#type-t">Reader.t</a></code></div><div class="spec value" id="val-stderr" class="anchored"><a href="#val-stderr" class="anchor"></a><code><span class="keyword">val</span> stderr : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Reader/index.html#type-t">Reader.t</a></code></div><div class="spec type" id="type-env" class="anchored"><a href="#type-env" class="anchor"></a><code><span class="keyword">type</span> env = <a href="../../../core/Core/Unix/index.html#type-env">Core.Unix.env</a></code></div><div><div class="spec include"><div class="doc"><div class="spec value" id="val-sexp_of_env" class="anchored"><a href="#val-sexp_of_env" class="anchor"></a><code><span class="keyword">val</span> sexp_of_env : <a href="index.html#type-env">env</a> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></div><div class="spec value" id="val-env_of_sexp" class="anchored"><a href="#val-env_of_sexp" class="anchor"></a><code><span class="keyword">val</span> env_of_sexp : <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a> <span>&#45;&gt;</span> <a href="index.html#type-env">env</a></code></div></div></div></div><div><div class="spec type" id="type-create" class="anchored"><a href="#type-create" class="anchor"></a><code><span class="keyword">type</span> <span>'a create</span> = <span>?&#8288;argv0:string</span> <span>&#45;&gt;</span> <span>?&#8288;buf_len:int</span> <span>&#45;&gt;</span> <span>?&#8288;env:<a href="index.html#type-env">env</a></span> <span>&#45;&gt;</span> <span>?&#8288;prog_search_path:<span>string list</span></span> <span>&#45;&gt;</span> <span>?&#8288;stdin:string</span> <span>&#45;&gt;</span> <span>?&#8288;working_dir:string</span> <span>&#45;&gt;</span> <span>prog:string</span> <span>&#45;&gt;</span> <span>args:<span>string list</span></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p><code>create ~prog ~args ()</code> uses <code>Core.Unix.create_process_env</code> to create a child process that runs the executable <code>prog</code> with <code>args</code> as arguments. It creates pipes to communicate with the child process's <code>stdin</code>, <code>stdout</code>, and <code>stderr</code>.</p><p>Unlike <code>exec</code>, <code>args</code> should not include <code>prog</code> as the first argument.</p><p>If <code>buf_len</code> is supplied, it determines the size of the reader and writer buffers used to communicate with the child process's <code>stdin</code>, <code>stdout</code>, and <code>stderr</code>.</p><p>If <code>stdin</code> is supplied, then the writer to the child's stdin will have <code>~raise_when_consumer_leaves:false</code> and <code>~buffer_age_limit:`Unlimited</code>, which makes it more robust.</p><p><code>env</code> specifies the environment of the child process.</p><p>If <code>working_dir</code> is supplied, then the child process will <code>chdir()</code> there before calling <code>exec()</code>.</p><p>If <code>argv0</code> is given, it is used (instead of <code>prog</code>) as the first element of the <code>argv</code> array passed to <code>exec</code>.</p><p><code>create</code> returns <code>Error</code> if it is unable to create the child process. This can happen in any number of situations (unable to fork, unable to create the pipes, unable to cd to <code>working_dir</code>, unable to <code>exec</code> etc.). <code>create</code> does not return <code>Error</code> if the binary exits with non-zero exit code; instead, it returns <code>OK t</code>, where <code>wait t</code> returns an <code>Error</code>.</p><p>See <code>Core.Unix.create_process_env</code> for more details.</p></div></div><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span><span><a href="index.html#type-t">t</a> <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a></span> <a href="index.html#type-create">create</a></span></code></div><div class="spec value" id="val-create_exn" class="anchored"><a href="#val-create_exn" class="anchor"></a><code><span class="keyword">val</span> create_exn : <span><a href="index.html#type-t">t</a> <a href="index.html#type-create">create</a></span></code></div><div><div class="spec value" id="val-wait" class="anchored"><a href="#val-wait" class="anchor"></a><code><span class="keyword">val</span> wait : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../../../core/Core/Unix/Exit_or_signal/index.html#type-t">Core.Unix.Exit_or_signal.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p><code>wait t = Unix.waitpid (pid t)</code>. <code>wait</code>'s result becomes determined when the child process terminates, via exit or signal. <code>wait</code> does not touch <code>stdin</code>, <code>stdout</code> or <code>stderr</code>. The caller should ensure that <code>stdout</code> and <code>stderr</code> are being drained in the background to avoid the child process blocking on a write due to pushback. See <code>collect_output_and_wait</code> for a higher-level alternative that handles this.</p></div></div><div class="spec module" id="module-Output" class="anchored"><a href="#module-Output" class="anchor"></a><code><span class="keyword">module</span> <a href="Output/index.html">Output</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec value" id="val-collect_output_and_wait" class="anchored"><a href="#val-collect_output_and_wait" class="anchor"></a><code><span class="keyword">val</span> collect_output_and_wait : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="Output/index.html#type-t">Output.t</a> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p><code>collect_output_and_wait t</code> closes <code>stdin t</code> and then begins collecting the output produced on <code>t</code>'s <code>stdout</code> and <code>stderr</code>, continuing to collect output until <code>t</code> terminates and the pipes for <code>stdout</code> and <code>stderr</code> are closed. Usually when <code>t</code> terminates, the pipes are closed; however, <code>t</code> could fork other processes which survive after <code>t</code> terminates and in turn keep the pipes open -- <code>collect_output_and_wait</code> will not become determined until both pipes are closed in all descendant processes.</p></div></div><div><div class="spec type" id="type-run" class="anchored"><a href="#type-run" class="anchor"></a><code><span class="keyword">type</span> <span>'a run</span> = <span>?&#8288;accept_nonzero_exit:<span>int list</span></span> <span>&#45;&gt;</span> <span>?&#8288;argv0:string</span> <span>&#45;&gt;</span> <span>?&#8288;env:<a href="index.html#type-env">env</a></span> <span>&#45;&gt;</span> <span>?&#8288;prog_search_path:<span>string list</span></span> <span>&#45;&gt;</span> <span>?&#8288;stdin:string</span> <span>&#45;&gt;</span> <span>?&#8288;working_dir:string</span> <span>&#45;&gt;</span> <span>prog:string</span> <span>&#45;&gt;</span> <span>args:<span>string list</span></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p><code>run</code> <code>create</code>s a process, feeds it <code>stdin</code> if provided, and <code>wait</code>s for it to complete. If the process exits with an acceptable status, then <code>run</code> returns its stdout. If the process exits unacceptably, then <code>run</code> returns an error indicating what went wrong that includes stdout and stderr.</p><p>Acceptable statuses are zero, and any nonzero values specified in <code>accept_nonzero_exit</code>.</p><p>Some care is taken so that an error displays nicely as a sexp---in particular, if the child's output can already be parsed as a sexp, then it will display as a sexp (rather than a sexp embedded in a string). Also, if the output isn't a sexp, it will be split on newlines into a list of strings, so that it displays on multiple lines rather than a single giant line with embedded &quot;\n&quot;'s.</p><p><code>run_lines</code> is like <code>run</code> but returns the lines of stdout as a string list, using <code>String.split_lines</code>.</p><p><code>run_expect_no_output</code> is like <code>run</code> but expects the command to produce no output, and returns an error if the command does produce output.</p></div></div><div class="spec value" id="val-run" class="anchored"><a href="#val-run" class="anchor"></a><code><span class="keyword">val</span> run : <span><span>string <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a></span> <a href="index.html#type-run">run</a></span></code></div><div class="spec value" id="val-run_exn" class="anchored"><a href="#val-run_exn" class="anchor"></a><code><span class="keyword">val</span> run_exn : <span>string <a href="index.html#type-run">run</a></span></code></div><div class="spec value" id="val-run_lines" class="anchored"><a href="#val-run_lines" class="anchor"></a><code><span class="keyword">val</span> run_lines : <span><span><span>string list</span> <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a></span> <a href="index.html#type-run">run</a></span></code></div><div class="spec value" id="val-run_lines_exn" class="anchored"><a href="#val-run_lines_exn" class="anchor"></a><code><span class="keyword">val</span> run_lines_exn : <span><span>string list</span> <a href="index.html#type-run">run</a></span></code></div><div class="spec value" id="val-run_expect_no_output" class="anchored"><a href="#val-run_expect_no_output" class="anchor"></a><code><span class="keyword">val</span> run_expect_no_output : <span><span>unit <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a></span> <a href="index.html#type-run">run</a></span></code></div><div class="spec value" id="val-run_expect_no_output_exn" class="anchored"><a href="#val-run_expect_no_output_exn" class="anchor"></a><code><span class="keyword">val</span> run_expect_no_output_exn : <span>unit <a href="index.html#type-run">run</a></span></code></div><div><div class="spec type" id="type-collect" class="anchored"><a href="#type-collect" class="anchor"></a><code><span class="keyword">type</span> <span>'a collect</span> = <span>?&#8288;accept_nonzero_exit:<span>int list</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p><code>collect_stdout_and_wait</code> and <code>collect_stdout_lines_and_wait</code> are like <code>run</code> and <code>run_lines</code> but work from an existing process instead of creating a new one.</p></div></div><div class="spec value" id="val-collect_stdout_and_wait" class="anchored"><a href="#val-collect_stdout_and_wait" class="anchor"></a><code><span class="keyword">val</span> collect_stdout_and_wait : <span><span>string <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a></span> <a href="index.html#type-collect">collect</a></span></code></div><div class="spec value" id="val-collect_stdout_and_wait_exn" class="anchored"><a href="#val-collect_stdout_and_wait_exn" class="anchor"></a><code><span class="keyword">val</span> collect_stdout_and_wait_exn : <span>string <a href="index.html#type-collect">collect</a></span></code></div><div class="spec value" id="val-collect_stdout_lines_and_wait" class="anchored"><a href="#val-collect_stdout_lines_and_wait" class="anchor"></a><code><span class="keyword">val</span> collect_stdout_lines_and_wait : <span><span><span>string list</span> <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a></span> <a href="index.html#type-collect">collect</a></span></code></div><div class="spec value" id="val-collect_stdout_lines_and_wait_exn" class="anchored"><a href="#val-collect_stdout_lines_and_wait_exn" class="anchor"></a><code><span class="keyword">val</span> collect_stdout_lines_and_wait_exn : <span><span>string list</span> <a href="index.html#type-collect">collect</a></span></code></div><div><div class="spec module" id="module-Lines_or_sexp" class="anchored"><a href="#module-Lines_or_sexp" class="anchor"></a><code><span class="keyword">module</span> <a href="Lines_or_sexp/index.html">Lines_or_sexp</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><p><code>Lines_or_sexp</code> is useful for rendering a string nicely in a sexp, avoiding quoting if the string is multi-line or was produced by converting a sexp to a string. <code>Output.sexp_of_t</code> uses <code>Lines_or_sexp</code> to nicely render stdout and stderr of a child process.</p></div></div></div></body></html>