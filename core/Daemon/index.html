<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Daemon (core.Daemon)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">core</a> &#x00BB; Daemon</nav><header><h1>Module <code>Daemon</code></h1><p>This module provides support for daemonizing a process. It provides flexibility as to where the standard file descriptors (stdin, stdout and stderr) are connected after daemonization has occurred.</p></header><div class="content"><div class="spec module" id="module-Fd_redirection" class="anchored"><a href="#module-Fd_redirection" class="anchor"></a><code><span class="keyword">module</span> <a href="Fd_redirection/index.html">Fd_redirection</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec value" id="val-daemonize" class="anchored"><a href="#val-daemonize" class="anchor"></a><code><span class="keyword">val</span> daemonize : <span>?&#8288;redirect_stdout:<a href="Fd_redirection/index.html#type-t">Fd_redirection.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;redirect_stderr:<a href="Fd_redirection/index.html#type-t">Fd_redirection.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;cd:string</span> <span>&#45;&gt;</span> <span>?&#8288;umask:int</span> <span>&#45;&gt;</span> <span>?&#8288;allow_threads_to_have_been_created:bool</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> unit</code></div><div><p><code>daemonize</code> makes the executing process a daemon.</p><p>The optional arguments have defaults as per <code>daemonize_wait</code>, below.</p><p>By default, output sent to stdout and stderr after daemonization will be silently eaten. This behaviour may be adjusted by using <code>redirect_stdout</code> and <code>redirect_stderr</code>. See the documentation for <code>daemonize_wait</code> below.</p><p>See <code>daemonize_wait</code> for a description of <code>allow_threads_to_have_been_created</code>.</p><p>Raises <code>Failure</code> if fork was unsuccessful.</p></div></div><div><div class="spec value" id="val-daemonize_wait" class="anchored"><a href="#val-daemonize_wait" class="anchor"></a><code><span class="keyword">val</span> daemonize_wait : <span>?&#8288;redirect_stdout:<a href="Fd_redirection/index.html#type-t">Fd_redirection.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;redirect_stderr:<a href="Fd_redirection/index.html#type-t">Fd_redirection.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;cd:string</span> <span>&#45;&gt;</span> <span>?&#8288;umask:int</span> <span>&#45;&gt;</span> <span>?&#8288;allow_threads_to_have_been_created:bool</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span><span>(unit <span>&#45;&gt;</span> unit)</span> <a href="../../base/Base/Staged/index.html#type-t">Core.Staged.t</a></span></code></div><div><p><code>daemonize_wait</code> makes the executing process a daemon, but delays full detachment from the calling shell/process until the returned &quot;release&quot; closure is called.</p><p>Any output to stdout/stderr before the &quot;release&quot; closure is called will get sent out normally. After &quot;release&quot; is called, stdin is connected to /dev/null, and stdout and stderr are connected as specified by <code>redirect_stdout</code> and <code>redirect_stderr</code>. The default is the usual behavior whereby both of these descriptors are connected to /dev/null. <code>daemonize_wait</code>, however, will not redirect stdout/stderr to /dev/null if they are already redirected to a regular file by default, i.e., default redirection is <code>`Dev_null_skip_regular_files</code>. This is to preserve behavior from earlier versions.)</p><p>Note that calling <code>release</code> will adjust SIGPIPE handling, so you should not rely on the delivery of this signal during this time.</p><p><code>daemonize_wait</code> allows you to daemonize and then start asynchronously, but still have stdout/stderr go to the controlling terminal during startup. By default, when you <code>daemonize</code>, toplevel exceptions during startup would get sent to /dev/null. With <code>daemonize_wait</code>, toplevel exceptions can go to the terminal until you call <code>release</code>.</p><p>Forking (especially to daemonize) when running multiple threads is tricky and generally a mistake. <code>daemonize</code> and <code>daemonize_wait</code> check that the current number of threads is not greater than expected. <code>daemonize_wait</code> and <code>daemonize</code> also check that threads have not been created, which is more conservative than the actual requirement that multiple threads are not running. Using <code>~allow_threads_to_have_been_created:true</code> bypasses that check. This is useful if Async was previously running, and therefore threads have been created, but has since been shut down. On non-Linux platforms, using <code>~allow_threads_to_have_been_created:true</code> eliminates the protection <code>daemonize</code> and <code>daemonize_wait</code> have regarding threads.</p><p>Raises <code>Failure</code> if forking was unsuccessful.</p></div></div></div></body></html>