<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Hacl_x25519 (hacl_x25519.Hacl_x25519)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> – <a href="../index.html">hacl_x25519</a> &#x00BB; Hacl_x25519</nav><header><h1>Module <code>Hacl_x25519</code></h1><p><a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">Diffie-Hellman key exchange</a> over <a href="https://en.wikipedia.org/wiki/Curve25519">Curve25519</a> (also known as X25519).</p><p>This implementation uses C code from <a href="https://project-everest.github.io/">Project Everest</a>, an effort to build and deploy a verified HTTPS stack.</p><dl><dt>see <a href="https://tools.ietf.org/html/rfc7748">https://tools.ietf.org/html/rfc7748</a></dt><dd><p>RFC7748, &quot;Elliptic Curves for Security&quot; - where this algorithm is defined.</p></dd></dl><dl><dt>see <a href="https://tools.ietf.org/html/rfc8446#section-7.4.2">https://tools.ietf.org/html/rfc8446#section-7.4.2</a></dt><dd><p>RFC8446, &quot;The Transport Layer Security (TLS) Protocol Version 1.3&quot;, section 7.4.2 - how to use this in the context of TLS 1.3.</p></dd></dl></header><div class="content"><div><div class="spec type" id="type-secret" class="anchored"><a href="#type-secret" class="anchor"></a><code><span class="keyword">type</span> secret</code></div><div><p>Key material. In elliptic curve terms, a scalar.</p><p>To generate a key pair, use <code>gen_key</code>.</p><p>In the usual setting, the private key only be generated and used for key exchange. But it can be useful to create values of type <code>secret</code> with a known value, for example to check against test vectors. One can use the following pattern to do this:</p><pre><code>let (secret, _) = gen_key ~rng:(fun _ -&gt; known_data) </code></pre></div></div><div><div class="spec value" id="val-gen_key" class="anchored"><a href="#val-gen_key" class="anchor"></a><code><span class="keyword">val</span> gen_key : <span>rng:<span>(int <span>&#45;&gt;</span> <a href="../../cstruct/Cstruct/index.html#type-t">Cstruct.t</a>)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-secret">secret</a> * <a href="../../cstruct/Cstruct/index.html#type-t">Cstruct.t</a></code></div><div><p>Generate a key pair. <code>rng</code> should return a <code>Cstruct.t</code> with the specified key length (in bytes) and fill it with random bytes.</p><p>If the cstruct returned by <code>rng</code> does not have the correct length, raises <code>Failure _</code>.</p></div></div><div><div class="spec value" id="val-encode_secret" class="anchored"><a href="#val-encode_secret" class="anchor"></a><code><span class="keyword">val</span> encode_secret : <a href="index.html#type-secret">secret</a> <span>&#45;&gt;</span> <a href="../../cstruct/Cstruct/index.html#type-t">Cstruct.t</a></code></div><div><p><code>encode_secret secret</code> is the secret encoded into a buffer.</p></div></div><div><div class="spec type" id="type-error" class="anchored"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error = [ </code><table><tr id="type-error.Invalid_length" class="anchored"><td class="def constructor"><a href="#type-error.Invalid_length" class="anchor"></a><code>| </code><code>`Invalid_length</code></td></tr><tr id="type-error.Low_order" class="anchored"><td class="def constructor"><a href="#type-error.Low_order" class="anchor"></a><code>| </code><code>`Low_order</code></td></tr></table><code> ]</code></div><div><p>Kind of errors.</p></div></div><div><div class="spec value" id="val-pp_error" class="anchored"><a href="#val-pp_error" class="anchor"></a><code><span class="keyword">val</span> pp_error : <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="index.html#type-error">error</a> <span>&#45;&gt;</span> unit</code></div><div><p>Pretty printer for errors</p></div></div><div><div class="spec value" id="val-key_exchange" class="anchored"><a href="#val-key_exchange" class="anchor"></a><code><span class="keyword">val</span> key_exchange : <a href="index.html#type-secret">secret</a> <span>&#45;&gt;</span> <a href="../../cstruct/Cstruct/index.html#type-t">Cstruct.t</a> <span>&#45;&gt;</span> <span><span>(<a href="../../cstruct/Cstruct/index.html#type-t">Cstruct.t</a>, <a href="index.html#type-error">error</a>)</span> <a href="../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span></code></div><div><p>Perform Diffie-Hellman key exchange between a private part and a public part.</p><p>It checks length of the <code>pub</code> key and returns an error if it has an incorrect length.</p><p>In DH terms, the private part corresponds to a scalar, and the public part corresponds to a point, and this computes the scalar multiplication.</p><p>The resulting shared secret is not truncated.</p><p>As described in <a href="https://tools.ietf.org/html/rfc7748#section-6.1">RFC 7748, section 6.1</a>, this function might internally generate an all-zero value. If this is the case <code>Error `Low_order</code> will be returned instead. <a href="https://tools.ietf.org/html/rfc8446#section-7.4.2">This check is necessary in the context of TLS 1.3</a>, but might not in other protocols.</p></div></div></div></body></html>