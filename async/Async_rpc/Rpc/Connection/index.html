<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Connection (async.Async_rpc.Rpc.Connection)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> – <a href="../../../index.html">async</a> &#x00BB; <a href="../../index.html">Async_rpc</a> &#x00BB; <a href="../index.html">Rpc</a> &#x00BB; Connection</nav><header><h1>Module <code>Rpc.Connection</code></h1></header><div class="content"><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <span class="keyword">struct</span> <span class="keyword">include</span> <a href="../../../../async_rpc_kernel/Async_rpc_kernel/Rpc/Connection/index.html">Async_rpc_kernel.Rpc.Connection</a> <span class="keyword">end</span></code></span></summary><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></div><div><div class="spec include"><div class="doc"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></div></div></div></div><div class="spec module" id="module-Heartbeat_config" class="anchored"><a href="#module-Heartbeat_config" class="anchor"></a><code><span class="keyword">module</span> <a href="Heartbeat_config/index.html">Heartbeat_config</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Client_implementations" class="anchored"><a href="#module-Client_implementations" class="anchor"></a><code><span class="keyword">module</span> <a href="Client_implementations/index.html">Client_implementations</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span>?&#8288;implementations:<span><span class="type-var">'s</span> <span class="xref-unresolved">Async_rpc_kernel__Implementations.t</span></span></span> <span>&#45;&gt;</span> <span>connection_state:<span>(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'s</span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;handshake_timeout:<a href="../../../../core_kernel/Core_kernel/Time_ns/Span/index.html#type-t">Core_kernel.Time_ns.Span.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;heartbeat_config:<a href="Heartbeat_config/index.html#type-t">Heartbeat_config.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;description:<a href="../../../../core_kernel/Core_kernel/Info/index.html#type-t">Core_kernel.Info.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;time_source:<a href="../../../../async_kernel/Async_kernel/Synchronous_time_source/index.html#type-t">Async_kernel.Synchronous_time_source.t</a></span> <span>&#45;&gt;</span> <span class="xref-unresolved">Async_rpc_kernel__Transport.t</span> <span>&#45;&gt;</span> <span><span><span>(<a href="index.html#type-t">t</a>, <a href="../../../../base/Base/Exn/index.html#type-t">Core_kernel.Exn.t</a>)</span> <a href="../../../../core_kernel/Core_kernel/Result/index.html#type-t">Core_kernel.Result.t</a></span> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p>Initiate an Rpc connection on the given transport. <code>implementations</code> should be the bag of implementations that the calling side implements; it defaults to <code>Implementations.null</code> (i.e., &quot;I implement no RPCs&quot;).</p><p><code>connection_state</code> will be called once, before <code>create</code>'s result is determined, on the same connection that <code>create</code> returns. Its output will be provided to the <code>implementations</code> when queries arrive.</p><p>WARNING: If specifying a custom <code>heartbeat_config</code>, make sure that both ends of the Rpc connection use compatible settings for timeout and send frequency. Otherwise, your Rpc connections might close unexpectedly.</p><p><code>description</code> can be used to give some extra information about the connection, which will then show up in error messages and the connection's sexp. If you have lots of connections in your program, this can be useful for distinguishing them.</p><p><code>time_source</code> can be given to define the time_source for which the heartbeating events will be scheduled. Defaults to wall-clock.</p></div></div><div><div class="spec value" id="val-contains_magic_prefix" class="anchored"><a href="#val-contains_magic_prefix" class="anchor"></a><code><span class="keyword">val</span> contains_magic_prefix : <span>bool <a href="../../../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a></span></code></div><div><p>As of Feb 2017, the RPC protocol started to contain a magic number so that one can identify RPC communication. The bool returned by <code>contains_magic_prefix</code> says whether this magic number was observed.</p></div></div><div class="spec value" id="val-description" class="anchored"><a href="#val-description" class="anchor"></a><code><span class="keyword">val</span> description : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../../../core_kernel/Core_kernel/Info/index.html#type-t">Core_kernel.Info.t</a></code></div><div><div class="spec value" id="val-add_heartbeat_callback" class="anchored"><a href="#val-add_heartbeat_callback" class="anchor"></a><code><span class="keyword">val</span> add_heartbeat_callback : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></div><div><p>After <code>add_heartbeat_callback t f</code>, <code>f ()</code> will be called on every subsequent heartbeat to <code>t</code>.</p></div></div><div><div class="spec value" id="val-close" class="anchored"><a href="#val-close" class="anchor"></a><code><span class="keyword">val</span> close : <span>?&#8288;streaming_responses_flush_timeout:<a href="../../../../core_kernel/Core_kernel/Time_ns/Span/index.html#type-t">Core_kernel.Time_ns.Span.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;reason:<a href="../../../../core_kernel/Core_kernel/Info/index.html#type-t">Core_kernel.Info.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>unit <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p><code>close</code> starts closing the connection's transport, and returns a deferred that becomes determined when its close completes. It is ok to call <code>close</code> multiple times on the same <code>t</code>; calls subsequent to the initial call will have no effect, but will return the same deferred as the original call.</p><p>Before closing the underlying transport's writer, <code>close</code> waits for all streaming reponses to be <code>Pipe.upstream_flushed</code> with a timeout of <code>streaming_responses_flush_timeout</code>.</p><p>The <code>reason</code> for closing the connection will be passed to callers of <code>close_reason</code>.</p></div></div><div><div class="spec value" id="val-close_finished" class="anchored"><a href="#val-close_finished" class="anchor"></a><code><span class="keyword">val</span> close_finished : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>unit <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p><code>close_finished</code> becomes determined after the close of the connection's transport completes, i.e. the same deferred that <code>close</code> returns. <code>close_finished</code> differs from <code>close</code> in that it does not have the side effect of initiating a close.</p></div></div><div><div class="spec value" id="val-close_reason" class="anchored"><a href="#val-close_reason" class="anchor"></a><code><span class="keyword">val</span> close_reason : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>on_close:<span>[ `started <span>| `finished</span> ]</span></span> <span>&#45;&gt;</span> <span><a href="../../../../core_kernel/Core_kernel/Info/index.html#type-t">Core_kernel.Info.t</a> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p><code>close_reason ~on_close t</code> becomes determined when close starts or finishes based on <code>on_close</code>, but additionally returns the reason that the connection was closed.</p></div></div><div><div class="spec value" id="val-is_closed" class="anchored"><a href="#val-is_closed" class="anchor"></a><code><span class="keyword">val</span> is_closed : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></div><div><p><code>is_closed t</code> returns <code>true</code> iff <code>close t</code> has been called. <code>close</code> may be called internally upon errors or timeouts.</p></div></div><div><div class="spec value" id="val-bytes_to_write" class="anchored"><a href="#val-bytes_to_write" class="anchor"></a><code><span class="keyword">val</span> bytes_to_write : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></div><div><p><code>bytes_to_write</code> and <code>flushed</code> just call the similarly named functions on the <code>Transport.Writer.t</code> within a connection.</p></div></div><div class="spec value" id="val-flushed" class="anchored"><a href="#val-flushed" class="anchor"></a><code><span class="keyword">val</span> flushed : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>unit <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><div class="spec value" id="val-with_close" class="anchored"><a href="#val-with_close" class="anchor"></a><code><span class="keyword">val</span> with_close : <span>?&#8288;implementations:<span><span class="type-var">'s</span> <span class="xref-unresolved">Async_rpc_kernel__Implementations.t</span></span></span> <span>&#45;&gt;</span> <span>?&#8288;handshake_timeout:<a href="../../../../core_kernel/Core_kernel/Time_ns/Span/index.html#type-t">Core_kernel.Time_ns.Span.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;heartbeat_config:<a href="Heartbeat_config/index.html#type-t">Heartbeat_config.t</a></span> <span>&#45;&gt;</span> <span>connection_state:<span>(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'s</span>)</span></span> <span>&#45;&gt;</span> <span class="xref-unresolved">Async_rpc_kernel__Transport.t</span> <span>&#45;&gt;</span> <span>dispatch_queries:<span>(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span>)</span></span> <span>&#45;&gt;</span> <span>on_handshake_error:<span>[ `Raise <span><span>| `Call</span> of <a href="../../../../base/Base/Exn/index.html#type-t">Core_kernel.Exn.t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span> ]</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p><code>with_close</code> tries to create a <code>t</code> using the given transport. If a handshake error is the result, it calls <code>on_handshake_error</code>, for which the default behavior is to raise an exception. If no error results, <code>dispatch_queries</code> is called on <code>t</code>.</p><p>After <code>dispatch_queries</code> returns, if <code>server</code> is None, the <code>t</code> will be closed and the deferred returned by <code>dispatch_queries</code> wil be determined immediately. Otherwise, we'll wait until the other side closes the connection and then close <code>t</code> and determine the deferred returned by <code>dispatch_queries</code>.</p><p>When the deferred returned by <code>with_close</code> becomes determined, <code>Transport.close</code> has finished.</p><p>NOTE: Because this connection is closed when the <code>Deferred.t</code> returned by <code>dispatch_queries</code> is determined, you should be careful when using this with <code>Pipe_rpc</code>. For example, simply returning the pipe when you get it will close the pipe immediately. You should instead either use the pipe inside <code>dispatch_queries</code> and not determine its result until you are done with the pipe, or use a different function like <code>create</code>.</p></div></div><div><div class="spec value" id="val-server_with_close" class="anchored"><a href="#val-server_with_close" class="anchor"></a><code><span class="keyword">val</span> server_with_close : <span>?&#8288;handshake_timeout:<a href="../../../../core_kernel/Core_kernel/Time_ns/Span/index.html#type-t">Core_kernel.Time_ns.Span.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;heartbeat_config:<a href="Heartbeat_config/index.html#type-t">Heartbeat_config.t</a></span> <span>&#45;&gt;</span> <span class="xref-unresolved">Async_rpc_kernel__Transport.t</span> <span>&#45;&gt;</span> <span>implementations:<span><span class="type-var">'s</span> <span class="xref-unresolved">Async_rpc_kernel__Implementations.t</span></span></span> <span>&#45;&gt;</span> <span>connection_state:<span>(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'s</span>)</span></span> <span>&#45;&gt;</span> <span>on_handshake_error:<span>[ `Raise <span>| `Ignore</span> <span><span>| `Call</span> of <a href="../../../../base/Base/Exn/index.html#type-t">Core_kernel.Exn.t</a> <span>&#45;&gt;</span> <span>unit <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span> ]</span></span> <span>&#45;&gt;</span> <span>unit <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p>Runs <code>with_close</code> but dispatches no queries. The implementations are required because this function doesn't let you dispatch any queries (i.e., act as a client), it would be pointless to call it if you didn't want to act as a server.</p></div></div></details></div></div></div><div><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span>?&#8288;implementations:<span><span class="type-var">'s</span> <a href="../../../../async_rpc_kernel/Async_rpc_kernel/Rpc/Implementations/index.html#type-t">Implementations.t</a></span></span> <span>&#45;&gt;</span> <span>connection_state:<span>(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'s</span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;max_message_size:int</span> <span>&#45;&gt;</span> <span>?&#8288;handshake_timeout:<a href="../../../../core/Core/Time/Span/index.html#type-t">Core.Time.Span.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;heartbeat_config:<a href="Heartbeat_config/index.html#type-t">Heartbeat_config.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;description:<a href="../../../../core_kernel/Core_kernel/Info/index.html#type-t">Core.Info.t</a></span> <span>&#45;&gt;</span> <a href="../../../../async_unix/Async_unix/Reader/index.html#type-t">Async_unix.Reader.t</a> <span>&#45;&gt;</span> <a href="../../../../async_unix/Async_unix/Writer/index.html#type-t">Async_unix.Writer.t</a> <span>&#45;&gt;</span> <span><span><span>(<a href="index.html#type-t">t</a>, <a href="../../../../base/Base/Exn/index.html#type-t">Core.Exn.t</a>)</span> <a href="../../../../core_kernel/Core_kernel/Result/index.html#type-t">Core.Result.t</a></span> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p>These functions are mostly the same as the ones with the same names in <code>Async_rpc_kernel.Rpc.Connection</code>; see <code>Connection_intf</code> in that library for documentation. The differences are that:</p><ul><li>they take an <code>Async_unix.Reader.t</code>, <code>Async_unix.Writer.t</code> and <code>max_message_size</code> instead of a <code>Transport.t</code></li><li>they use <code>Time</code> instead of <code>Time_ns</code></li></ul></div></div><div><div class="spec value" id="val-contains_magic_prefix" class="anchored"><a href="#val-contains_magic_prefix" class="anchor"></a><code><span class="keyword">val</span> contains_magic_prefix : <a href="../../../../async_unix/Async_unix/Reader/index.html#type-t">Async_unix.Reader.t</a> <span>&#45;&gt;</span> <span>bool <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p>As of Feb 2017, the RPC protocol started to contain a magic number so that one can identify RPC communication. The bool returned by <code>contains_magic_prefix</code> says whether this magic number was observed.</p><p>This operation is a &quot;peek&quot; that does not advance any pointers associated with the reader. In particular, it makes sense to call <code>create</code> on a reader after calling this function.</p></div></div><div class="spec value" id="val-with_close" class="anchored"><a href="#val-with_close" class="anchor"></a><code><span class="keyword">val</span> with_close : <span>?&#8288;implementations:<span><span class="type-var">'s</span> <a href="../../../../async_rpc_kernel/Async_rpc_kernel/Rpc/Implementations/index.html#type-t">Implementations.t</a></span></span> <span>&#45;&gt;</span> <span>?&#8288;max_message_size:int</span> <span>&#45;&gt;</span> <span>?&#8288;handshake_timeout:<a href="../../../../core/Core/Time/Span/index.html#type-t">Core.Time.Span.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;heartbeat_config:<a href="Heartbeat_config/index.html#type-t">Heartbeat_config.t</a></span> <span>&#45;&gt;</span> <span>connection_state:<span>(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'s</span>)</span></span> <span>&#45;&gt;</span> <a href="../../../../async_unix/Async_unix/Reader/index.html#type-t">Async_unix.Reader.t</a> <span>&#45;&gt;</span> <a href="../../../../async_unix/Async_unix/Writer/index.html#type-t">Async_unix.Writer.t</a> <span>&#45;&gt;</span> <span>dispatch_queries:<span>(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span>)</span></span> <span>&#45;&gt;</span> <span>on_handshake_error:<span>[ `Raise <span><span>| `Call</span> of <a href="../../../../base/Base/Exn/index.html#type-t">Core.Exn.t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span> ]</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div class="spec value" id="val-server_with_close" class="anchored"><a href="#val-server_with_close" class="anchor"></a><code><span class="keyword">val</span> server_with_close : <span>?&#8288;max_message_size:int</span> <span>&#45;&gt;</span> <span>?&#8288;handshake_timeout:<a href="../../../../core/Core/Time/Span/index.html#type-t">Core.Time.Span.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;heartbeat_config:<a href="Heartbeat_config/index.html#type-t">Heartbeat_config.t</a></span> <span>&#45;&gt;</span> <a href="../../../../async_unix/Async_unix/Reader/index.html#type-t">Async_unix.Reader.t</a> <span>&#45;&gt;</span> <a href="../../../../async_unix/Async_unix/Writer/index.html#type-t">Async_unix.Writer.t</a> <span>&#45;&gt;</span> <span>implementations:<span><span class="type-var">'s</span> <a href="../../../../async_rpc_kernel/Async_rpc_kernel/Rpc/Implementations/index.html#type-t">Implementations.t</a></span></span> <span>&#45;&gt;</span> <span>connection_state:<span>(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'s</span>)</span></span> <span>&#45;&gt;</span> <span>on_handshake_error:<span>[ `Raise <span>| `Ignore</span> <span><span>| `Call</span> of <a href="../../../../base/Base/Exn/index.html#type-t">Core.Exn.t</a> <span>&#45;&gt;</span> <span>unit <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span> ]</span></span> <span>&#45;&gt;</span> <span>unit <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><div class="spec type" id="type-transport_maker" class="anchored"><a href="#type-transport_maker" class="anchor"></a><code><span class="keyword">type</span> transport_maker = <a href="../../../../async_unix/Async_unix/Fd/index.html#type-t">Async_unix.Fd.t</a> <span>&#45;&gt;</span> <span>max_message_size:int</span> <span>&#45;&gt;</span> <a href="../Transport/index.html#type-t">Transport.t</a></code></div><div><p>A function creating a transport from a file descriptor. It is responsible for setting the low-level parameters of the underlying transport.</p><p>For instance to set up a transport using <code>Async.{Reader,Writer}</code> and set a buffer age limit on the writer, you can pass this to the functions of this module:</p><pre><code>~make_transport:(fun fd ~max_message_size -&gt;
  Rpc.Transport.of_fd fd ~max_message_size ~buffer_age_limit:`Unlimited)</code></pre></div></div><div class="spec type" id="type-on_handshake_error" class="anchored"><a href="#type-on_handshake_error" class="anchor"></a><code><span class="keyword">type</span> on_handshake_error = [ </code><table><tr id="type-on_handshake_error.Raise" class="anchored"><td class="def constructor"><a href="#type-on_handshake_error.Raise" class="anchor"></a><code>| </code><code>`Raise</code></td></tr><tr id="type-on_handshake_error.Ignore" class="anchored"><td class="def constructor"><a href="#type-on_handshake_error.Ignore" class="anchor"></a><code>| </code><code>`Ignore</code></td></tr><tr id="type-on_handshake_error.Call" class="anchored"><td class="def constructor"><a href="#type-on_handshake_error.Call" class="anchor"></a><code>| </code><code>`Call <span class="keyword">of</span> <a href="../../../../base/Base/Exn/index.html#type-t">Core.Exn.t</a> <span>&#45;&gt;</span> unit</code></td></tr></table><code> ]</code></div><div><div class="spec value" id="val-serve" class="anchored"><a href="#val-serve" class="anchor"></a><code><span class="keyword">val</span> serve : <span>implementations:<span><span class="type-var">'s</span> <a href="../../../../async_rpc_kernel/Async_rpc_kernel/Rpc/Implementations/index.html#type-t">Implementations.t</a></span></span> <span>&#45;&gt;</span> <span>initial_connection_state:<span>(<span class="type-var">'address</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'s</span>)</span></span> <span>&#45;&gt;</span> <span>where_to_listen:<span><span>(<span class="type-var">'address</span>, <span class="type-var">'listening_on</span>)</span> <a href="../../../../async_unix/Async_unix/Tcp/Where_to_listen/index.html#type-t">Async_unix.Tcp.Where_to_listen.t</a></span></span> <span>&#45;&gt;</span> <span>?&#8288;max_connections:int</span> <span>&#45;&gt;</span> <span>?&#8288;backlog:int</span> <span>&#45;&gt;</span> <span>?&#8288;max_message_size:int</span> <span>&#45;&gt;</span> <span>?&#8288;make_transport:<a href="index.html#type-transport_maker">transport_maker</a></span> <span>&#45;&gt;</span> <span>?&#8288;handshake_timeout:<a href="../../../../core/Core/Time/Span/index.html#type-t">Core.Time.Span.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;heartbeat_config:<a href="Heartbeat_config/index.html#type-t">Heartbeat_config.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;auth:<span>(<span class="type-var">'address</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>?&#8288;on_handshake_error:<a href="index.html#type-on_handshake_error">on_handshake_error</a></span> <span>&#45;&gt;</span> <span>?&#8288;on_handler_error:<span>[ `Raise <span>| `Ignore</span> <span><span>| `Call</span> of <span class="type-var">'address</span> <span>&#45;&gt;</span> exn <span>&#45;&gt;</span> unit</span> ]</span></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'address</span>, <span class="type-var">'listening_on</span>)</span> <a href="../../../../async_unix/Async_unix/Tcp/Server/index.html#type-t">Async_unix.Tcp.Server.t</a></span> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p><code>serve implementations ~port ?on_handshake_error ()</code> starts a server with the given implementation on <code>port</code>. The optional auth function will be called on all incoming connections with the address info of the client and will disconnect the client immediately if it returns false. This auth mechanism is generic and does nothing other than disconnect the client -- any logging or record of the reasons is the responsibility of the auth function itself.</p></div></div><div class="spec value" id="val-serve_with_transport" class="anchored"><a href="#val-serve_with_transport" class="anchor"></a><code><span class="keyword">val</span> serve_with_transport : <span>handshake_timeout:<span><a href="../../../../core/Core/Time/Span/index.html#type-t">Core.Time.Span.t</a> option</span></span> <span>&#45;&gt;</span> <span>heartbeat_config:<span><a href="Heartbeat_config/index.html#type-t">Heartbeat_config.t</a> option</span></span> <span>&#45;&gt;</span> <span>implementations:<span><span class="type-var">'s</span> <a href="../../../../async_rpc_kernel/Async_rpc_kernel/Rpc/Implementations/index.html#type-t">Implementations.t</a></span></span> <span>&#45;&gt;</span> <span>description:<a href="../../../../core_kernel/Core_kernel/Info/index.html#type-t">Core.Info.t</a></span> <span>&#45;&gt;</span> <span>connection_state:<span>(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'s</span>)</span></span> <span>&#45;&gt;</span> <span>on_handshake_error:<a href="index.html#type-on_handshake_error">on_handshake_error</a></span> <span>&#45;&gt;</span> <a href="../Transport/index.html#type-t">Transport.t</a> <span>&#45;&gt;</span> <span>unit <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><div class="spec value" id="val-client" class="anchored"><a href="#val-client" class="anchor"></a><code><span class="keyword">val</span> client : <span>?&#8288;implementations:<span><span class="type-var">_</span> <a href="Client_implementations/index.html#type-t">Client_implementations.t</a></span></span> <span>&#45;&gt;</span> <span>?&#8288;max_message_size:int</span> <span>&#45;&gt;</span> <span>?&#8288;make_transport:<a href="index.html#type-transport_maker">transport_maker</a></span> <span>&#45;&gt;</span> <span>?&#8288;handshake_timeout:<a href="../../../../core/Core/Time/Span/index.html#type-t">Core.Time.Span.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;heartbeat_config:<a href="Heartbeat_config/index.html#type-t">Heartbeat_config.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;description:<a href="../../../../core_kernel/Core_kernel/Info/index.html#type-t">Core.Info.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="../../../../async_unix/Async_unix/Tcp/Where_to_connect/index.html#type-t">Async_unix.Tcp.Where_to_connect.t</a></span> <span>&#45;&gt;</span> <span><span><span>(<a href="index.html#type-t">t</a>, <a href="../../../../base/Base/Exn/index.html#type-t">Core.Exn.t</a>)</span> <a href="../../../../core_kernel/Core_kernel/Result/index.html#type-t">Core.Result.t</a></span> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p><code>client where_to_connect ()</code> connects to the server at <code>where_to_connect</code> and returns the connection or an Error if a connection could not be made. It is the responsibility of the caller to eventually call <code>close</code>.</p><p>In <code>client</code> and <code>with_client</code>, the <code>handshake_timeout</code> encompasses both the TCP connection timeout and the timeout for this module's own handshake.</p></div></div><div><div class="spec value" id="val-client'" class="anchored"><a href="#val-client'" class="anchor"></a><code><span class="keyword">val</span> client' : <span>?&#8288;implementations:<span><span class="type-var">_</span> <a href="Client_implementations/index.html#type-t">Client_implementations.t</a></span></span> <span>&#45;&gt;</span> <span>?&#8288;max_message_size:int</span> <span>&#45;&gt;</span> <span>?&#8288;make_transport:<a href="index.html#type-transport_maker">transport_maker</a></span> <span>&#45;&gt;</span> <span>?&#8288;handshake_timeout:<a href="../../../../core/Core/Time/Span/index.html#type-t">Core.Time.Span.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;heartbeat_config:<a href="Heartbeat_config/index.html#type-t">Heartbeat_config.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;description:<a href="../../../../core_kernel/Core_kernel/Info/index.html#type-t">Core.Info.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'transport</span> <a href="../../../../async_unix/Async_unix/Tcp/Where_to_connect/index.html#type-t">Async_unix.Tcp.Where_to_connect.t</a></span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'transport</span> * <a href="index.html#type-t">t</a>, <a href="../../../../base/Base/Exn/index.html#type-t">Core.Exn.t</a>)</span> <a href="../../../../core_kernel/Core_kernel/Result/index.html#type-t">Core.Result.t</a></span> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p>Similar to <code>client</code>, but additionally expose the <code>Socket.Address.t</code> of the RPC server that we connected to.</p></div></div><div><div class="spec value" id="val-with_client" class="anchored"><a href="#val-with_client" class="anchor"></a><code><span class="keyword">val</span> with_client : <span>?&#8288;implementations:<span><span class="type-var">_</span> <a href="Client_implementations/index.html#type-t">Client_implementations.t</a></span></span> <span>&#45;&gt;</span> <span>?&#8288;max_message_size:int</span> <span>&#45;&gt;</span> <span>?&#8288;make_transport:<a href="index.html#type-transport_maker">transport_maker</a></span> <span>&#45;&gt;</span> <span>?&#8288;handshake_timeout:<a href="../../../../core/Core/Time/Span/index.html#type-t">Core.Time.Span.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;heartbeat_config:<a href="Heartbeat_config/index.html#type-t">Heartbeat_config.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="../../../../async_unix/Async_unix/Tcp/Where_to_connect/index.html#type-t">Async_unix.Tcp.Where_to_connect.t</a></span> <span>&#45;&gt;</span> <span>(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span>)</span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'a</span>, <a href="../../../../base/Base/Exn/index.html#type-t">Core.Exn.t</a>)</span> <a href="../../../../core_kernel/Core_kernel/Result/index.html#type-t">Core.Result.t</a></span> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p><code>with_client where_to_connect f</code> connects to the server at <code>where_to_connect</code> and runs f until an exception is thrown or until the returned Deferred is fulfilled.</p><p>NOTE: As with <code>with_close</code>, you should be careful when using this with <code>Pipe_rpc</code>. See <code>with_close</code> for more information.</p></div></div><div><div class="spec value" id="val-with_client'" class="anchored"><a href="#val-with_client'" class="anchor"></a><code><span class="keyword">val</span> with_client' : <span>?&#8288;implementations:<span><span class="type-var">_</span> <a href="Client_implementations/index.html#type-t">Client_implementations.t</a></span></span> <span>&#45;&gt;</span> <span>?&#8288;max_message_size:int</span> <span>&#45;&gt;</span> <span>?&#8288;make_transport:<a href="index.html#type-transport_maker">transport_maker</a></span> <span>&#45;&gt;</span> <span>?&#8288;handshake_timeout:<a href="../../../../core/Core/Time/Span/index.html#type-t">Core.Time.Span.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;heartbeat_config:<a href="Heartbeat_config/index.html#type-t">Heartbeat_config.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'transport</span> <a href="../../../../async_unix/Async_unix/Tcp/Where_to_connect/index.html#type-t">Async_unix.Tcp.Where_to_connect.t</a></span> <span>&#45;&gt;</span> <span>(<span>remote_server:<span class="type-var">'transport</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span>)</span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'a</span>, <a href="../../../../base/Base/Exn/index.html#type-t">Core.Exn.t</a>)</span> <a href="../../../../core_kernel/Core_kernel/Result/index.html#type-t">Core.Result.t</a></span> <a href="../../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p>Similar to <code>with_client</code>, but additionally expose the <code>Socket.Address.t</code> of the RPC server that we connected to.</p></div></div></div></body></html>