<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Deferred (async_kernel.Async_kernel.Deferred)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_kernel</a> &#x00BB; <a href="../index.html">Async_kernel</a> &#x00BB; Deferred</nav><header><h1>Module <code>Async_kernel.Deferred</code></h1><p>A value that will become determined asynchronously.</p><p>A deferred can be &quot;undetermined&quot; or &quot;determined&quot;. A deferred that is undetermined may at some point become determined with value v, and will henceforth always be determined with value v.</p></header><nav class="toc"><ul><li><a href="#deferred-collections">Deferred collections</a></li><li><a href="#error-carrying-deferreds">Error-carrying deferreds</a></li></ul></nav><div class="content"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>+'a t</span></code></div><div><div class="spec include"><div class="doc"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></div></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../base/Base/Invariant/module-type-S1/index.html">Core_kernel.Invariant.S1</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="../../../base/Base/Invariant/module-type-S1/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></span></summary><div class="spec value" id="val-invariant" class="anchored"><a href="#val-invariant" class="anchor"></a><code><span class="keyword">val</span> invariant : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></div></details></div></div></div><aside><p><code>sexp_of_t t f</code> returns a sexp of the deferred's value, if it is determined, or an informative string otherwise.</p><p>This is just for display purposes. There is no <code>t_of_sexp</code>.</p></aside><div><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span>(<span><span class="type-var">'a</span> <a href="../Ivar/index.html#type-t">Ivar.t</a></span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>create f</code> calls <code>f i</code>, where <code>i</code> is an empty ivar. <code>create</code> returns a deferred that becomes determined when <code>f</code> fills <code>i</code>.</p></div></div><div><div class="spec value" id="val-upon" class="anchored"><a href="#val-upon" class="anchor"></a><code><span class="keyword">val</span> upon : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></div><div><p><code>upon t f</code> will run <code>f v</code> at some point after <code>t</code> becomes determined with value <code>v</code>.</p></div></div><div><div class="spec value" id="val-peek" class="anchored"><a href="#val-peek" class="anchor"></a><code><span class="keyword">val</span> peek : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></div><div><p><code>peek t</code> returns <code>Some v</code> iff <code>t</code> is determined with value <code>v</code>.</p></div></div><div><div class="spec value" id="val-value_exn" class="anchored"><a href="#val-value_exn" class="anchor"></a><code><span class="keyword">val</span> value_exn : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></div><div><p><code>value_exn t</code> returns <code>v</code> if <code>t</code> is determined with value <code>v</code>, and raises otherwise.</p></div></div><div><div class="spec value" id="val-is_determined" class="anchored"><a href="#val-is_determined" class="anchor"></a><code><span class="keyword">val</span> is_determined : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></div><div><p><code>is_determined t</code> returns <code>true</code> iff <code>t</code> is determined.</p></div></div><div><div class="spec include"><div class="doc"><p>Deferreds form a monad.</p><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../core_kernel/Core_kernel/module-type-Monad/index.html">Core_kernel.Monad</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="../../../core_kernel/Core_kernel/module-type-Monad/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></span></summary><div><div class="spec include"><div class="doc"><div><div class="spec include"><div class="doc"><div><div class="spec value" id="val-(&gt;&gt;=)" class="anchored"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>t &gt;&gt;= f</code> returns a computation that sequences the computations represented by two monad elements. The resulting computation first does <code>t</code> to yield a value <code>v</code>, and then runs the computation returned by <code>f v</code>.</p></div></div><div><div class="spec value" id="val-(&gt;&gt;|)" class="anchored"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;|) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>t &gt;&gt;| f</code> is <code>t &gt;&gt;= (fun a -&gt; return (f a))</code>.</p></div></div></div></div></div><div class="spec module" id="module-Monad_infix" class="anchored"><a href="#module-Monad_infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Monad_infix/index.html">Monad_infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec value" id="val-bind" class="anchored"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val</span> bind : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>bind t ~f</code> = <code>t &gt;&gt;= f</code></p></div></div><div><div class="spec value" id="val-return" class="anchored"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>return v</code> returns the (trivial) computation that returns v.</p></div></div><div><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>map t ~f</code> is t &gt;&gt;| f.</p></div></div><div><div class="spec value" id="val-join" class="anchored"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>join t</code> is <code>t &gt;&gt;= (fun t' -&gt; t')</code>.</p></div></div><div><div class="spec value" id="val-ignore_m" class="anchored"><a href="#val-ignore_m" class="anchor"></a><code><span class="keyword">val</span> ignore_m : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>ignore_m t</code> is <code>map t ~f:(fun _ -&gt; ())</code>. <code>ignore_m</code> used to be called <code>ignore</code>, but we decided that was a bad name, because it shadowed the widely used <code>Caml.ignore</code>. Some monads still do <code>let ignore = ignore_m</code> for historical reasons.</p></div></div><div class="spec value" id="val-all" class="anchored"><a href="#val-all" class="anchor"></a><code><span class="keyword">val</span> all : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><div class="spec value" id="val-all_unit" class="anchored"><a href="#val-all_unit" class="anchor"></a><code><span class="keyword">val</span> all_unit : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p>Like <code>all</code>, but ensures that every monadic value in the list produces a unit value, all of which are discarded rather than being collected into a list.</p></div></div></div></div></div><div><div class="spec include"><div class="doc"><div class="spec module" id="module-Let_syntax" class="anchored"><a href="#module-Let_syntax" class="anchor"></a><code><span class="keyword">module</span> <a href="Let_syntax/index.html">Let_syntax</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></div></div></details></div></div></div><div class="spec module" id="module-Infix" class="anchored"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec value" id="val-unit" class="anchored"><a href="#val-unit" class="anchor"></a><code><span class="keyword">val</span> unit : <span>unit <a href="index.html#type-t">t</a></span></code></div><div><p><code>unit</code> is a deferred that is always determined with value <code>()</code></p></div></div><div class="spec value" id="val-ignore" class="anchored"><a href="#val-ignore" class="anchor"></a><code><span class="keyword">val</span> ignore : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></div><div><div class="spec value" id="val-never" class="anchored"><a href="#val-never" class="anchor"></a><code><span class="keyword">val</span> never : unit <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>never ()</code> returns a deferred that never becomes determined.</p></div></div><div><div class="spec value" id="val-both" class="anchored"><a href="#val-both" class="anchor"></a><code><span class="keyword">val</span> both : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>both t1 t2</code> becomes determined after both <code>t1</code> and <code>t2</code> become determined.</p></div></div><div><div class="spec value" id="val-all" class="anchored"><a href="#val-all" class="anchor"></a><code><span class="keyword">val</span> all : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>all ts</code> returns a deferred that becomes determined when every <code>t</code> in <code>t</code>s is determined. The output is in the same order as the input.</p></div></div><div><div class="spec value" id="val-all_unit" class="anchored"><a href="#val-all_unit" class="anchor"></a><code><span class="keyword">val</span> all_unit : <span><span>unit <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></div><div><p>Like <code>all</code>, but ignores results of the component deferreds.</p></div></div><div><div class="spec value" id="val-any" class="anchored"><a href="#val-any" class="anchor"></a><code><span class="keyword">val</span> any : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>any ts</code> returns a deferred that is determined when any of the underlying deferreds is determined.</p></div></div><div><div class="spec value" id="val-any_unit" class="anchored"><a href="#val-any_unit" class="anchor"></a><code><span class="keyword">val</span> any_unit : <span><span>unit <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></div><div><p><code>any_unit</code> is like <code>any</code>, but ignores results of the component deferreds.</p></div></div><div><div class="spec value" id="val-don't_wait_for" class="anchored"><a href="#val-don't_wait_for" class="anchor"></a><code><span class="keyword">val</span> don't_wait_for : <span>unit <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></div><div><p><code>don't_wait_for t</code> ignores <code>t</code>. It is like <code>Fn.ignore</code>, but is more constrained because it requires a <code>unit Deferred.t</code>.</p><p>Rather than <code>ignore (t : _ t)</code>, do <code>don't_wait_for (Deferred.ignore t)</code>.</p><p>We chose to give <code>don't_wait_for</code> type <code>unit t</code> rather than <code>_ t</code> to catch errors where a value is accidentally ignored.</p></div></div><div><div class="spec module" id="module-Choice" class="anchored"><a href="#module-Choice" class="anchor"></a><code><span class="keyword">module</span> <a href="Choice/index.html">Choice</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><p>A <code>Choice.t</code> is used to produce an argument to <code>enabled</code> or <code>choose</code>. See below.</p></div></div><div class="spec type" id="type-choice" class="anchored"><a href="#type-choice" class="anchor"></a><code><span class="keyword">type</span> <span>'a choice</span> = <span><span class="type-var">'a</span> <a href="Choice/index.html#type-t">Choice.t</a></span></code></div><div class="spec value" id="val-choice" class="anchored"><a href="#val-choice" class="anchor"></a><code><span class="keyword">val</span> choice : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="Choice/index.html#type-t">Choice.t</a></span></code></div><div><div class="spec value" id="val-enabled" class="anchored"><a href="#val-enabled" class="anchor"></a><code><span class="keyword">val</span> enabled : <span><span><span class="type-var">'b</span> <a href="Choice/index.html#type-t">Choice.t</a></span> list</span> <span>&#45;&gt;</span> <span><span>(unit <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span>)</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>enabled [choice t1 f1; ... choice tn fn;]</code> returns a deferred <code>d</code> that becomes determined when any of the <code>ti</code> becomes determined. The value of <code>d</code> is a function <code>f</code> that when called, for each <code>ti</code> that is enabled, applies <code>fi</code> to <code>ti</code>, and returns a list of the results. It is guaranteed that the list is in the same order as the choices supplied to <code>enabled</code>, but of course it may be shorter than the input list if not all <code>ti</code> are determined.</p></div></div><div><div class="spec value" id="val-choose" class="anchored"><a href="#val-choose" class="anchor"></a><code><span class="keyword">val</span> choose : <span><span><span class="type-var">'b</span> <a href="Choice/index.html#type-t">Choice.t</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></div><div><pre><code>choose [ choice t1 f1
       ; ...
         ; choice tn fn ] </code></pre><p>returns a deferred <code>t</code> that becomes determined with value <code>fi ai</code> after some <code>ti</code> becomes determined with value <code>ai</code>. It is guaranteed that <code>choose</code> calls at most one of the <code>fi</code>s, the one that determines its result. There is no guarantee that the <code>ti</code> that becomes determined earliest in time will be the one whose value determines the <code>choose</code>. Nor is it guaranteed that the value in <code>t</code> is the first value (in place order) from <code>choices</code> that is determined at the time <code>t</code> is examined.</p><p>For example, in:</p><pre><code>choose [ choice t1 (fun () -&gt; `X1)
       ; choice t2 (fun () -&gt; `X2) ]
&gt;&gt;&gt; function
| `X1 -&gt; e1
| `X2 -&gt; e2 </code></pre><p>it may be the case that both <code>t1</code> and <code>t2</code> become determined, yet <code>e2</code> actually runs.</p><p>It is guaranteed that if multiple choices are determined with no intervening asynchrony, then the earliest choice in the list will become the value of the <code>choose</code>.</p></div></div><div><div class="spec value" id="val-for_" class="anchored"><a href="#val-for_" class="anchor"></a><code><span class="keyword">val</span> for_ : int <span>&#45;&gt;</span> <span>to_:int</span> <span>&#45;&gt;</span> <span>do_:<span>(int <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span>)</span></span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-t">t</a></span></code></div><div><p><code>for_ start ~to_:stop ~do_:f</code> is the deferred analog of:</p><pre><code>for i = start to stop do
  f i;
done </code></pre></div></div><div><div class="spec value" id="val-repeat_until_finished" class="anchored"><a href="#val-repeat_until_finished" class="anchor"></a><code><span class="keyword">val</span> repeat_until_finished : <span class="type-var">'state</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'state</span> <span>&#45;&gt;</span> <span><span>[ <span>`Repeat of <span class="type-var">'state</span></span> <span><span>| `Finished</span> of <span class="type-var">'result</span></span> ]</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'result</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>repeat_until_finished initial_state f</code> repeatedly runs <code>f</code> until <code>f</code> returns <code>`Finished</code>. The first call to <code>f</code> happens immediately when <code>repeat_until_finished</code> is called.</p></div></div><div><div class="spec value" id="val-forever" class="anchored"><a href="#val-forever" class="anchor"></a><code><span class="keyword">val</span> forever : <span class="type-var">'state</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'state</span> <span>&#45;&gt;</span> <span><span class="type-var">'state</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> unit</code></div><div><p><code>forever initial_state f</code> repeatedly runs <code>f</code>, supplying the state returned to the next call to <code>f</code>.</p></div></div><div><div class="spec value" id="val-ok" class="anchored"><a href="#val-ok" class="anchor"></a><code><span class="keyword">val</span> ok : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'a</span>,Â <span class="type-var">_</span>)</span> <a href="../../../core_kernel/Core_kernel/Result/index.html#type-t">Core_kernel.Result.t</a></span> <a href="index.html#type-t">t</a></span></code></div><div><p>Useful for lifting values from the <code>Deferred.t</code> monad to the <code>Result.t Deferred.t</code> monad.</p></div></div><h3 id="deferred-collections"><a href="#deferred-collections" class="anchor"></a>Deferred collections</h3><aside><p>These contain operations for iterating in a deferred manner over different collection types.</p></aside><div class="spec module" id="module-Array" class="anchored"><a href="#module-Array" class="anchor"></a><code><span class="keyword">module</span> <a href="Array/index.html">Array</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-List" class="anchored"><a href="#module-List" class="anchor"></a><code><span class="keyword">module</span> <a href="List/index.html">List</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Map" class="anchored"><a href="#module-Map" class="anchor"></a><code><span class="keyword">module</span> <a href="Map/index.html">Map</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec module" id="module-Memo" class="anchored"><a href="#module-Memo" class="anchor"></a><code><span class="keyword">module</span> <a href="Memo/index.html">Memo</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><p>Memoization functions like in <code>Core_kernel.Memo</code>, with re-raising of exceptions thrown asynchronously.</p></div></div><div><div class="spec module" id="module-Queue" class="anchored"><a href="#module-Queue" class="anchor"></a><code><span class="keyword">module</span> <a href="Queue/index.html">Queue</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><p>All <code>Deferred_queue</code> iteration functions first copy the queue (to a list) and then start calling the user function <code>f</code>. So, if <code>f</code> modifies the queue, that will have no effect on the iteration.</p></div></div><div class="spec module" id="module-Sequence" class="anchored"><a href="#module-Sequence" class="anchor"></a><code><span class="keyword">module</span> <a href="Sequence/index.html">Sequence</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><h3 id="error-carrying-deferreds"><a href="#error-carrying-deferreds" class="anchor"></a>Error-carrying deferreds</h3><aside><p>These contain interfaces for working with deferred type containing error-aware types, like <code>'a Option.t Deferred.t</code>, or <code>'a Or_error.t Deferred.t</code>. These all include support for monadic programming.</p></aside><div class="spec module" id="module-Option" class="anchored"><a href="#module-Option" class="anchor"></a><code><span class="keyword">module</span> <a href="Option/index.html">Option</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec module" id="module-Or_error" class="anchored"><a href="#module-Or_error" class="anchor"></a><code><span class="keyword">module</span> <a href="Or_error/index.html">Or_error</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><p>The deferred analog of <code>Core.Or_error</code>. It is exposed in std.ml as <code>Deferred.Or_error</code>.</p></div></div><div class="spec module" id="module-Result" class="anchored"><a href="#module-Result" class="anchor"></a><code><span class="keyword">module</span> <a href="Result/index.html">Result</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>