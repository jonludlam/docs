<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mvar (async_kernel.Async_kernel.Mvar)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> – <a href="../../index.html">async_kernel</a> &#x00BB; <a href="../index.html">Async_kernel</a> &#x00BB; Mvar</nav><header><h1>Module <code>Async_kernel.Mvar</code></h1><p>An <code>Mvar</code> is a mutable location that is either empty or contains a value. One can <code>put</code> or <code>set</code> the value, and wait on <code>value_available</code> for the location to be filled in either way.</p><p>Having an <code>Mvar.Read_write.t</code> gives the capability to mutate the mvar.</p><p>The key difference between an <code>Mvar</code> and an <a href="../Ivar/index.html"><code>Ivar</code></a> is that an <code>Mvar</code> may be filled multiple times.</p><p>This implementation of <code>Mvar</code> also allows one to replace the value without any guarantee that the reading side has seen it. This is useful in situations where last-value semantics are desired (e.g., you want to signal whenever a config file is updated, but only care about the most recent contents).</p><p>An <code>Mvar</code> can also be used as a baton-passing mechanism between a producer and consumer. For instance, a producer reading from a socket and producing a set of deserialized messages can <code>put</code> the batch from a single read into an <code>Mvar</code> and can wait for <code>taken</code> to return as a pushback mechanism. The consumer meanwhile waits on <code>value_available</code>. This way the natural batch size is passed between the two sub-systems with minimal overhead.</p></header><div class="content"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>('a, -'phantom) t</span></code></div><div><div class="spec include"><div class="doc"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'phantom</span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'phantom</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></div></div></div></div><div class="spec module" id="module-Read_write" class="anchored"><a href="#module-Read_write" class="anchor"></a><code><span class="keyword">module</span> <a href="Read_write/index.html">Read_write</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Read_only" class="anchored"><a href="#module-Read_only" class="anchor"></a><code><span class="keyword">module</span> <a href="Read_only/index.html">Read_only</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : unit <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Read_write/index.html#type-t">Read_write.t</a></span></code></div><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></div><div><div class="spec value" id="val-put" class="anchored"><a href="#val-put" class="anchor"></a><code><span class="keyword">val</span> put : <span><span>(<span class="type-var">'a</span>, <span>[&gt; <a href="../../../core_kernel/Core_kernel/index.html#type-write">Core_kernel.write</a> ]</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>put t a</code> waits until <code>is_empty t</code>, and then does <code>set t a</code>. If there are multiple concurrent <code>put</code>s, there is no fairness guarantee (i.e., <code>put</code>s may happen out of order or may be starved).</p></div></div><div><div class="spec value" id="val-set" class="anchored"><a href="#val-set" class="anchor"></a><code><span class="keyword">val</span> set : <span><span>(<span class="type-var">'a</span>, <span>[&gt; <a href="../../../core_kernel/Core_kernel/index.html#type-write">Core_kernel.write</a> ]</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></div><div><p><code>set t a</code> sets the value in <code>t</code> to <code>a</code>, even if <code>not (is_empty t)</code>. This is useful if you want takers to have last-value semantics.</p></div></div><div><div class="spec value" id="val-update" class="anchored"><a href="#val-update" class="anchor"></a><code><span class="keyword">val</span> update : <span><span>(<span class="type-var">'a</span>, <a href="../../../core_kernel/Core_kernel/index.html#type-read_write">Core_kernel.read_write</a>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> unit</code></div><div><p><code>update t ~f</code> applies <code>f</code> to the value in <code>t</code> and <code>set</code>s <code>t</code> to the result. This is useful if you want takers to have accumulated-value semantics.</p></div></div><div><div class="spec value" id="val-update_exn" class="anchored"><a href="#val-update_exn" class="anchor"></a><code><span class="keyword">val</span> update_exn : <span><span>(<span class="type-var">'a</span>, <a href="../../../core_kernel/Core_kernel/index.html#type-read_write">Core_kernel.read_write</a>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> unit</code></div><div><p><code>update_exn</code> is like <code>update</code>, except it raises if <code>is_empty t</code>.</p></div></div><div class="spec value" id="val-read_only" class="anchored"><a href="#val-read_only" class="anchor"></a><code><span class="keyword">val</span> read_only : <span><span>(<span class="type-var">'a</span>, <span>[&gt; <a href="../../../core_kernel/Core_kernel/index.html#type-read">Core_kernel.read</a> ]</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <a href="../../../core_kernel/Core_kernel/index.html#type-read">Core_kernel.read</a>)</span> <a href="index.html#type-t">t</a></span></code></div><div class="spec value" id="val-write_only" class="anchored"><a href="#val-write_only" class="anchor"></a><code><span class="keyword">val</span> write_only : <span><span>(<span class="type-var">'a</span>, <span>[&gt; <a href="../../../core_kernel/Core_kernel/index.html#type-write">Core_kernel.write</a> ]</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <a href="../../../core_kernel/Core_kernel/index.html#type-write">Core_kernel.write</a>)</span> <a href="index.html#type-t">t</a></span></code></div><div><div class="spec value" id="val-value_available" class="anchored"><a href="#val-value_available" class="anchor"></a><code><span class="keyword">val</span> value_available : <span><span>(<span class="type-var">_</span>, <span>[&gt; <a href="../../../core_kernel/Core_kernel/index.html#type-read">Core_kernel.read</a> ]</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>value_available t</code> returns a deferred <code>d</code> that becomes determined when a value is in <code>t</code>. <code>d</code> does not include the value in <code>t</code> because that value may change after <code>d</code> becomes determined and before a deferred bind on <code>d</code> gets to run.</p><p>Repeated calls to <code>value_available t</code> will always return the same deferred until the <code>t</code> is filled.</p></div></div><div><div class="spec value" id="val-take" class="anchored"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : <span><span>(<span class="type-var">'a</span>, <span>[&gt; <a href="../../../core_kernel/Core_kernel/index.html#type-read">Core_kernel.read</a> ]</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>take t</code> returns a deferred that, when <code>t</code> is filled, becomes determined with the value of <code>t</code> and and clears <code>t</code>. If there are multiple concurrent calls to <code>take</code> then only one of them will be fulfilled and the others will continue waiting on future values. There is no ordering guarantee for which <code>take</code> call will be filled first.</p></div></div><div><div class="spec value" id="val-take_now" class="anchored"><a href="#val-take_now" class="anchor"></a><code><span class="keyword">val</span> take_now : <span><span>(<span class="type-var">'a</span>, <span>[&gt; <a href="../../../core_kernel/Core_kernel/index.html#type-read">Core_kernel.read</a> ]</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></div><div><p><code>take_now</code> is an immediate form of <code>take</code>.</p></div></div><div class="spec value" id="val-take_now_exn" class="anchored"><a href="#val-take_now_exn" class="anchor"></a><code><span class="keyword">val</span> take_now_exn : <span><span>(<span class="type-var">'a</span>, <span>[&gt; <a href="../../../core_kernel/Core_kernel/index.html#type-read">Core_kernel.read</a> ]</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></div><div><div class="spec value" id="val-taken" class="anchored"><a href="#val-taken" class="anchor"></a><code><span class="keyword">val</span> taken : <span><span>(<span class="type-var">_</span>, <span>[&gt; <a href="../../../core_kernel/Core_kernel/index.html#type-write">Core_kernel.write</a> ]</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>taken t</code> returns a deferred that is filled the next time <code>take</code> clears <code>t</code>.</p></div></div><div><div class="spec value" id="val-peek" class="anchored"><a href="#val-peek" class="anchor"></a><code><span class="keyword">val</span> peek : <span><span>(<span class="type-var">'a</span>, <span>[&gt; <a href="../../../core_kernel/Core_kernel/index.html#type-read">Core_kernel.read</a> ]</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></div><div><p><code>peek t</code> returns the value in <code>t</code> without clearing <code>t</code>, or returns <code>None</code> is <code>is_empty
    t</code>.</p></div></div><div><div class="spec value" id="val-peek_exn" class="anchored"><a href="#val-peek_exn" class="anchor"></a><code><span class="keyword">val</span> peek_exn : <span><span>(<span class="type-var">'a</span>, <span>[&gt; <a href="../../../core_kernel/Core_kernel/index.html#type-read">Core_kernel.read</a> ]</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></div><div><p><code>peek_exn t</code> is like <code>peek</code>, except it raises if <code>is_empty t</code>.</p></div></div><div><div class="spec value" id="val-pipe_when_ready" class="anchored"><a href="#val-pipe_when_ready" class="anchor"></a><code><span class="keyword">val</span> pipe_when_ready : <span><span>(<span class="type-var">'a</span>, <span>[&gt; <a href="../../../core_kernel/Core_kernel/index.html#type-read">Core_kernel.read</a> ]</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Pipe/Reader/index.html#type-t">Pipe.Reader.t</a></span></code></div><div><p><code>pipe_when_ready t</code> returns a pipe, then repeatedly takes a value from <code>t</code> and writes it to the pipe. After each write, <code>pipe_when_ready</code> waits for the pipe to be ready to accept another value before taking the next value. Once the pipe is closed, <code>pipe_when_ready</code> will no longer take values from <code>t</code>.</p><p>Notice that this implementation effectively creates an extra buffer of size 1, so when you read from the pipe you can read a stale value (even though a fresh one should come immediately afterwards), and a value will be taken from the MVar even if it's never read from the pipe.</p><p>There is no protection against creating multiple pipes or otherwise multiple things trying to <code>take</code> concurrently. If that happens, it's not specified which of the pipes will get the value.</p></div></div></div></body></html>