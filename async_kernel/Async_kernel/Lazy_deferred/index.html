<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lazy_deferred (async_kernel.Async_kernel.Lazy_deferred)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_kernel</a> &#x00BB; <a href="../index.html">Async_kernel</a> &#x00BB; Lazy_deferred</nav><header><h1>Module <code>Async_kernel.Lazy_deferred</code></h1><p>A delayed computation that can produce a deferred.</p><p>Nothing happens with a lazy deferred unless one <code>force</code>s it. Forcing a lazy deferred starts the computation, which will eventually cause the deferred to become determined. As usual with laziness, multiply forcing a lazy deferred is no different than forcing it a single time.</p><p>Exceptions (both synchronous and asynchronous) raised by a delayed computation are returned by <code>force</code> (<code>wait</code>, <code>peek</code>, etc.), or will be raised to the monitor in effect when <code>force_exn</code> (<code>wait_exn</code>, <code>peek_exn</code>, etc.) was called.</p><p>The type is not exposed nor defined as <code>'a Deferred.t Lazy.t</code> or <code>'a Or_error.t
    Deferred.t Lazy.t</code>, because there is a difference in power with these types. Any value of type <code>'a Deferred.t Lazy.t</code> would mishandle asynchronous exceptions in the computation of <code>'a</code>. For instance, the following code blocks forever regardless of how <code>v</code> is defined:</p><pre><code>let v : Nothing.t Deferred.t Lazy.t = lazy (return &quot;&quot; &gt;&gt;| failwith) in
let%bind _ = try_with (fun () -&gt; force v) in
let%bind _ = try_with (fun () -&gt; force v) in</code></pre><p>There is no <code>val of_lazy : 'a Deferred.t Lazy.t -&gt; 'a t</code> because of the difference in power.</p><p>See also <code>Deferred.Memo.unit</code>, if you only are interested in <code>create</code> and <code>force</code>.</p></header><div class="content"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></div><div><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span>(unit <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>create f</code> creates a new lazy deferred that will call <code>f</code> when it is forced.</p></div></div><div><div class="spec value" id="val-force" class="anchored"><a href="#val-force" class="anchor"></a><code><span class="keyword">val</span> force : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core_kernel.Or_error.t</a></span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>force t</code> forces evaluation of <code>t</code> and returns a deferred that becomes determined when the deferred computation becomes determined or raises.</p></div></div><div class="spec value" id="val-force_exn" class="anchored"><a href="#val-force_exn" class="anchor"></a><code><span class="keyword">val</span> force_exn : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><div class="spec value" id="val-wait" class="anchored"><a href="#val-wait" class="anchor"></a><code><span class="keyword">val</span> wait : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core_kernel.Or_error.t</a></span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>wait t</code> and <code>wait_exn t</code> waits for <code>t</code> to be forced. If no one ever calls <code>force t</code>, they will wait forever.</p></div></div><div class="spec value" id="val-wait_exn" class="anchored"><a href="#val-wait_exn" class="anchor"></a><code><span class="keyword">val</span> wait_exn : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><div class="spec include"><div class="doc"><p><code>bind t f</code> in the lazy-deferred monad creates a computation that, when forced, will force <code>t</code>, apply <code>f</code> to the result, and then force the result of that.</p><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../../core_kernel/Core_kernel/module-type-Monad/index.html">Core_kernel.Monad</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="../../../core_kernel/Core_kernel/module-type-Monad/index.html#type-t">t</a></span> := <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></span></summary><div><div class="spec include"><div class="doc"><div><div class="spec include"><div class="doc"><div><div class="spec value" id="val-(&gt;&gt;=)" class="anchored"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>t &gt;&gt;= f</code> returns a computation that sequences the computations represented by two monad elements. The resulting computation first does <code>t</code> to yield a value <code>v</code>, and then runs the computation returned by <code>f v</code>.</p></div></div><div><div class="spec value" id="val-(&gt;&gt;|)" class="anchored"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;|) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>t &gt;&gt;| f</code> is <code>t &gt;&gt;= (fun a -&gt; return (f a))</code>.</p></div></div></div></div></div><div class="spec module" id="module-Monad_infix" class="anchored"><a href="#module-Monad_infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Monad_infix/index.html">Monad_infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec value" id="val-bind" class="anchored"><a href="#val-bind" class="anchor"></a><code><span class="keyword">val</span> bind : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>bind t ~f</code> = <code>t &gt;&gt;= f</code></p></div></div><div><div class="spec value" id="val-return" class="anchored"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>return v</code> returns the (trivial) computation that returns v.</p></div></div><div><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>map t ~f</code> is t &gt;&gt;| f.</p></div></div><div><div class="spec value" id="val-join" class="anchored"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>join t</code> is <code>t &gt;&gt;= (fun t' -&gt; t')</code>.</p></div></div><div><div class="spec value" id="val-ignore_m" class="anchored"><a href="#val-ignore_m" class="anchor"></a><code><span class="keyword">val</span> ignore_m : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>ignore_m t</code> is <code>map t ~f:(fun _ -&gt; ())</code>. <code>ignore_m</code> used to be called <code>ignore</code>, but we decided that was a bad name, because it shadowed the widely used <code>Caml.ignore</code>. Some monads still do <code>let ignore = ignore_m</code> for historical reasons.</p></div></div><div class="spec value" id="val-all" class="anchored"><a href="#val-all" class="anchor"></a><code><span class="keyword">val</span> all : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><div class="spec value" id="val-all_unit" class="anchored"><a href="#val-all_unit" class="anchor"></a><code><span class="keyword">val</span> all_unit : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p>Like <code>all</code>, but ensures that every monadic value in the list produces a unit value, all of which are discarded rather than being collected into a list.</p></div></div></div></div></div><div><div class="spec include"><div class="doc"><div class="spec module" id="module-Let_syntax" class="anchored"><a href="#module-Let_syntax" class="anchor"></a><code><span class="keyword">module</span> <a href="Let_syntax/index.html">Let_syntax</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></div></div></details></div></div></div><div><div class="spec value" id="val-bind'" class="anchored"><a href="#val-bind'" class="anchor"></a><code><span class="keyword">val</span> bind' : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>bind'</code> differs from <code>bind</code> in that the supplied function produces an <code>'a Deferred.t</code> rather than an <code>'a t</code>.</p></div></div><aside><p>Read-only operations.</p></aside><div><div class="spec value" id="val-peek" class="anchored"><a href="#val-peek" class="anchor"></a><code><span class="keyword">val</span> peek : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core_kernel.Or_error.t</a></span> option</span></code></div><div><p><code>peek t = Deferred.peek (wait t)</code></p></div></div><div class="spec value" id="val-peek_exn" class="anchored"><a href="#val-peek_exn" class="anchor"></a><code><span class="keyword">val</span> peek_exn : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></div><div class="spec value" id="val-is_determined" class="anchored"><a href="#val-is_determined" class="anchor"></a><code><span class="keyword">val</span> is_determined : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></div><div class="spec value" id="val-is_forced" class="anchored"><a href="#val-is_forced" class="anchor"></a><code><span class="keyword">val</span> is_forced : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></div></div></body></html>