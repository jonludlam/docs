<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Gc (async_kernel.Async_kernel.Gc)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_kernel</a> &#x00BB; <a href="../index.html">Async_kernel</a> &#x00BB; Gc</nav><header><h1>Module <code>Async_kernel.Gc</code></h1><p>Async's analog of <code>Core_kernel.Gc</code>.</p></header><div class="content"><div><div class="spec include"><div class="doc"><p>We remove the <code>Expert</code> module, which has functions that are superseded by Async-friendly functions below.</p><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../../../core_kernel/Core_kernel/Gc/index.html">Core_kernel.Gc</a> <span class="keyword">with</span> <span class="keyword">module</span> <a href="../../../core_kernel/Core_kernel__Gc/Expert/index.html">Expert</a> := <a href="../../../core_kernel/Core_kernel/Gc/Expert/index.html">Core_kernel.Gc.Expert</a></code></span></summary><aside><p>This is a wrapper around INRIA's standard <code>Gc</code> module. Provides memory management control and statistics, and finalized values.</p></aside><div class="spec module" id="module-Stat" class="anchored"><a href="#module-Stat" class="anchor"></a><code><span class="keyword">module</span> <a href="Stat/index.html">Stat</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec type" id="type-stat" class="anchored"><a href="#type-stat" class="anchor"></a><code><span class="keyword">type</span> stat = <a href="Stat/index.html#type-t">Stat.t</a></code></div><aside><p>The memory management counters are returned in a <code>stat</code> record.</p><p>The total amount of memory allocated by the program since it was started is (in words) <code>minor_words + major_words - promoted_words</code>. Multiply by the word size (4 on a 32-bit machine, 8 on a 64-bit machine) to get the number of bytes.</p></aside><div class="spec module" id="module-Control" class="anchored"><a href="#module-Control" class="anchor"></a><code><span class="keyword">module</span> <a href="Control/index.html">Control</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec type" id="type-control" class="anchored"><a href="#type-control" class="anchor"></a><code><span class="keyword">type</span> control = <a href="Control/index.html#type-t">Control.t</a></code></div><aside><p>The GC parameters are given as a <code>control</code> record. Note that these parameters can also be initialised by setting the OCAMLRUNPARAM environment variable. See the documentation of ocamlrun.</p></aside><div><div class="spec external" id="val-stat" class="anchored"><a href="#val-stat" class="anchor"></a><code><span class="keyword">val</span> stat : <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="index.html#type-stat">stat</a></code></div><div><p>Return the current values of the memory management counters in a <code>stat</code> record. This function examines every heap block to get the statistics.</p></div></div><div><div class="spec external" id="val-quick_stat" class="anchored"><a href="#val-quick_stat" class="anchor"></a><code><span class="keyword">val</span> quick_stat : <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="index.html#type-stat">stat</a></code></div><div><p>Same as <code>stat</code> except that <code>live_words</code>, <code>live_blocks</code>, <code>free_words</code>, <code>free_blocks</code>, <code>largest_free</code>, and <code>fragments</code> are set to 0. This function is much faster than <code>stat</code> because it does not need to go through the heap.</p></div></div><div><div class="spec external" id="val-counters" class="anchored"><a href="#val-counters" class="anchor"></a><code><span class="keyword">val</span> counters : <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Float/index.html#type-t">Base.Float.t</a> * <a href="../../../base/Base/Float/index.html#type-t">Base.Float.t</a> * <a href="../../../base/Base/Float/index.html#type-t">Base.Float.t</a></code></div><div><p>Return <code>(minor_words, promoted_words, major_words)</code>. This function is as fast at <code>quick_stat</code>.</p></div></div><div><div class="spec external" id="val-minor_words" class="anchored"><a href="#val-minor_words" class="anchor"></a><code><span class="keyword">val</span> minor_words : <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></code></div><div><p>The following functions return the same as <code>(Gc.quick_stat ()).Stat.f</code>, avoiding any allocation (of the <code>stat</code> record or a float). On 32-bit machines the <code>int</code> may overflow.</p><p>Note that <code>minor_words</code> does not allocate, but we do not annotate it as <code>noalloc</code> because we want the compiler to save the value of the allocation pointer register (%r15 on x86-64) to the global variable <code>caml_young_ptr</code> before the C stub tries to read its value.</p></div></div><div class="spec external" id="val-major_words" class="anchored"><a href="#val-major_words" class="anchor"></a><code><span class="keyword">val</span> major_words : <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></code></div><div class="spec external" id="val-promoted_words" class="anchored"><a href="#val-promoted_words" class="anchor"></a><code><span class="keyword">val</span> promoted_words : <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></code></div><div class="spec external" id="val-minor_collections" class="anchored"><a href="#val-minor_collections" class="anchor"></a><code><span class="keyword">val</span> minor_collections : <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></code></div><div class="spec external" id="val-major_collections" class="anchored"><a href="#val-major_collections" class="anchor"></a><code><span class="keyword">val</span> major_collections : <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></code></div><div class="spec external" id="val-heap_words" class="anchored"><a href="#val-heap_words" class="anchor"></a><code><span class="keyword">val</span> heap_words : <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></code></div><div class="spec external" id="val-heap_chunks" class="anchored"><a href="#val-heap_chunks" class="anchor"></a><code><span class="keyword">val</span> heap_chunks : <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></code></div><div class="spec external" id="val-compactions" class="anchored"><a href="#val-compactions" class="anchor"></a><code><span class="keyword">val</span> compactions : <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></code></div><div class="spec external" id="val-top_heap_words" class="anchored"><a href="#val-top_heap_words" class="anchor"></a><code><span class="keyword">val</span> top_heap_words : <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></code></div><div><div class="spec external" id="val-major_plus_minor_words" class="anchored"><a href="#val-major_plus_minor_words" class="anchor"></a><code><span class="keyword">val</span> major_plus_minor_words : <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></code></div><div><p>This function returns <code>major_words () + minor_words ()</code>. It exists purely for speed (one call into C rather than two). Like <code>major_words</code> and <code>minor_words</code>, <code>major_plus_minor_words</code> avoids allocating a <code>stat</code> record or a float, and may overflow on 32-bit machines.</p><p>This function is not marked <code>[@@noalloc]</code> to ensure that the allocation pointer is up-to-date when the minor-heap measurement is made.</p></div></div><div><div class="spec external" id="val-get" class="anchored"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="index.html#type-control">control</a></code></div><div><p>Return the current values of the GC parameters in a <code>control</code> record.</p></div></div><div><div class="spec external" id="val-set" class="anchored"><a href="#val-set" class="anchor"></a><code><span class="keyword">val</span> set : <a href="index.html#type-control">control</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a></code></div><div><p><code>set r</code> changes the GC parameters according to the <code>control</code> record <code>r</code>. The normal usage is: <code>Gc.set { (Gc.get()) with Gc.Control.verbose = 0x00d }</code></p></div></div><div><div class="spec external" id="val-minor" class="anchored"><a href="#val-minor" class="anchor"></a><code><span class="keyword">val</span> minor : <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a></code></div><div><p>Trigger a minor collection.</p></div></div><div><div class="spec external" id="val-major_slice" class="anchored"><a href="#val-major_slice" class="anchor"></a><code><span class="keyword">val</span> major_slice : <a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></code></div><div><p>Do a minor collection and a slice of major collection. The argument is the size of the slice, 0 to use the automatically-computed slice size. In all cases, the result is the computed slice size.</p></div></div><div><div class="spec external" id="val-major" class="anchored"><a href="#val-major" class="anchor"></a><code><span class="keyword">val</span> major : <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a></code></div><div><p>Do a minor collection and finish the current major collection cycle.</p></div></div><div><div class="spec external" id="val-full_major" class="anchored"><a href="#val-full_major" class="anchor"></a><code><span class="keyword">val</span> full_major : <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a></code></div><div><p>Do a minor collection, finish the current major collection cycle, and perform a complete new cycle. This will collect all currently unreachable blocks.</p></div></div><div><div class="spec external" id="val-compact" class="anchored"><a href="#val-compact" class="anchor"></a><code><span class="keyword">val</span> compact : <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a></code></div><div><p>Perform a full major collection and compact the heap. Note that heap compaction is a lengthy operation.</p></div></div><div><div class="spec value" id="val-print_stat" class="anchored"><a href="#val-print_stat" class="anchor"></a><code><span class="keyword">val</span> print_stat : <a href="../../../ocaml/Stdlib/index.html#type-out_channel">Stdlib.out_channel</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a></code></div><div><p>Print the current values of the memory management counters (in human-readable form) into the channel argument.</p></div></div><div><div class="spec value" id="val-allocated_bytes" class="anchored"><a href="#val-allocated_bytes" class="anchor"></a><code><span class="keyword">val</span> allocated_bytes : <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Float/index.html#type-t">Base.Float.t</a></code></div><div><p>Return the total number of bytes allocated since the program was started. It is returned as a <code>float</code> to avoid overflow problems with <code>int</code> on 32-bit machines.</p></div></div><div><div class="spec value" id="val-keep_alive" class="anchored"><a href="#val-keep_alive" class="anchor"></a><code><span class="keyword">val</span> keep_alive : <span class="type-var">_</span> <span>&#45;&gt;</span> <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a></code></div><div><p><code>keep_alive a</code> ensures that <code>a</code> is live at the point where <code>keep_alive a</code> is called. It is like <code>ignore a</code>, except that the compiler won't be able to simplify it and potentially collect <code>a</code> too soon.</p></div></div><div><div class="spec module" id="module-Allocation_policy" class="anchored"><a href="#module-Allocation_policy" class="anchor"></a><code><span class="keyword">module</span> <a href="Allocation_policy/index.html">Allocation_policy</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><p>The policy used for allocating in the heap.</p></div></div><div><div class="spec value" id="val-tune" class="anchored"><a href="#val-tune" class="anchor"></a><code><span class="keyword">val</span> tune : <span>?&#8288;logger:<span>(<a href="../../../base/Base/String/index.html#type-t">Base.String.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;minor_heap_size:<a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;major_heap_increment:<a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;space_overhead:<a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;verbose:<a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;max_overhead:<a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;stack_limit:<a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;allocation_policy:<a href="Allocation_policy/index.html#type-t">Allocation_policy.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;window_size:<a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;custom_major_ratio:<a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;custom_minor_ratio:<a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;custom_minor_max_size:<a href="../../../base/Base/Int/index.html#type-t">Base.Int.t</a></span> <span>&#45;&gt;</span> <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a></code></div><div><p>Adjust the specified GC parameters.</p></div></div><div class="spec value" id="val-disable_compaction" class="anchored"><a href="#val-disable_compaction" class="anchor"></a><code><span class="keyword">val</span> disable_compaction : <span>?&#8288;logger:<span>(<a href="../../../base/Base/String/index.html#type-t">Base.String.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a>)</span></span> <span>&#45;&gt;</span> <span>allocation_policy:<span>[ `Don't_change <span><span>| `Set_to</span> of <a href="Allocation_policy/index.html#type-t">Allocation_policy.t</a></span> ]</span></span> <span>&#45;&gt;</span> <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a> <span>&#45;&gt;</span> <a href="../../../base/Base/Unit/index.html#type-t">Base.Unit.t</a></code></div><div class="spec module" id="module-Stable" class="anchored"><a href="#module-Stable" class="anchor"></a><code><span class="keyword">module</span> <a href="Stable/index.html">Stable</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></details></div></div></div><div><div class="spec value" id="val-add_finalizer" class="anchored"><a href="#val-add_finalizer" class="anchor"></a><code><span class="keyword">val</span> add_finalizer : <span><span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Heap_block/index.html#type-t">Core_kernel.Heap_block.t</a></span> <span>&#45;&gt;</span> <span>(<span><span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Heap_block/index.html#type-t">Core_kernel.Heap_block.t</a></span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></div><div><p><code>add_finalizer b f</code> ensures that <code>f</code> runs after <code>b</code> becomes unreachable. <code>f b</code> will run in its own Async job. If <code>f</code> raises, the unhandled exception will be raised to the monitor that called <code>add_finalizer b f</code>.</p><p>The OCaml runtime only supports finalizers on heap blocks, hence <code>add_finalizer</code> requires <code>b : _ Heap_block.t</code>.</p><p>The runtime essentially maintains a set of finalizer pairs:</p><pre><code>'a Heap_block.t * ('a Heap_block.t -&gt; unit)</code></pre><p>Each call to <code>add_finalizer</code> adds a new pair to the set. It is allowed for many pairs to have the same heap block, the same function, or both. Each pair is a distinct element of the set.</p><p>After a garbage collection determines that a heap block <code>b</code> is unreachable, it removes from the set of finalizers all finalizer pairs <code>(b, f)</code> whose block is <code>b</code>, and then and runs <code>f b</code> for all such pairs. Thus, a finalizer registered with <code>add_finalizer</code> will run at most once.</p><p>In a finalizer pair <code>(b, f)</code>, it is a mistake for the closure of <code>f</code> to reference (directly or indirectly) <code>b</code> -- <code>f</code> should only access <code>b</code> via its argument. Referring to <code>b</code> in any other way will cause <code>b</code> to be kept alive forever, since <code>f</code> itself is a root of garbage collection, and can itself only be collected after the pair <code>(b, f)</code> is removed from the set of finalizers.</p><p>The <code>f</code> function can use all features of OCaml and Async, since it runs as an ordinary Async job. <code>f</code> can even make <code>b</code> reachable again. It can even call <code>add_finalizer</code> on <code>b</code> or other values to register other finalizer functions.</p></div></div><div><div class="spec value" id="val-add_finalizer_exn" class="anchored"><a href="#val-add_finalizer_exn" class="anchor"></a><code><span class="keyword">val</span> add_finalizer_exn : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></div><div><p><code>add_finalizer_exn b f</code> is like <a href="index.html#val-add_finalizer"><code>add_finalizer</code></a>, but will raise if <code>b</code> is not a heap block.</p></div></div><div><div class="spec value" id="val-add_finalizer_last" class="anchored"><a href="#val-add_finalizer_last" class="anchor"></a><code><span class="keyword">val</span> add_finalizer_last : <span><span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Heap_block/index.html#type-t">Core_kernel.Heap_block.t</a></span> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></div><div><p>Same as <a href="index.html#val-add_finalizer"><code>add_finalizer</code></a> except that the function is not called until the value has become unreachable for the last time. This means that the finalization function does not receive the value as an argument. Every weak pointer and ephemeron that contained this value as key or data is unset before running the finalization function.</p></div></div><div class="spec value" id="val-add_finalizer_last_exn" class="anchored"><a href="#val-add_finalizer_last_exn" class="anchor"></a><code><span class="keyword">val</span> add_finalizer_last_exn : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></div><div><div class="spec module" id="module-Alarm" class="anchored"><a href="#module-Alarm" class="anchor"></a><code><span class="keyword">module</span> <a href="Alarm/index.html">Alarm</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><p>A GC alarm calls a user function after the end of each major GC cycle.</p></div></div></div></body></html>