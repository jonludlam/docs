<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Clock (async_kernel.Async_kernel.Clock_ns.Clock)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">async_kernel</a> &#x00BB; <a href="../../index.html">Async_kernel</a> &#x00BB; <a href="../index.html">Clock_ns</a> &#x00BB; Clock</nav><header><h1>Module type <code>Clock_ns.Clock</code></h1></header><div class="content"><div class="spec module" id="module-Time" class="anchored"><a href="#module-Time" class="anchor"></a><code><span class="keyword">module</span> <a href="Time/index.html">Time</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec value" id="val-run_at" class="anchored"><a href="#val-run_at" class="anchor"></a><code><span class="keyword">val</span> run_at : <a href="Time/index.html#type-t">Time.t</a> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></div><div><p><code>run_at time f a</code> runs <code>f a</code> as soon as possible after <code>time</code>. If <code>time</code> is in the past, then <code>run_at</code> will immediately schedule a job <code>t</code> that will run <code>f a</code>. In no situation will <code>run_at</code> actually call <code>f</code> itself. The call to <code>f</code> will always be in another job.</p></div></div><div><div class="spec value" id="val-run_after" class="anchored"><a href="#val-run_after" class="anchor"></a><code><span class="keyword">val</span> run_after : <a href="Time/Span/index.html#type-t">Time.Span.t</a> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></div><div><p><code>run_after</code> is like <code>run_at</code>, except that one specifies a time span rather than an absolute time.</p></div></div><div><div class="spec value" id="val-at" class="anchored"><a href="#val-at" class="anchor"></a><code><span class="keyword">val</span> at : <a href="Time/index.html#type-t">Time.t</a> <span>&#45;&gt;</span> <span>unit <span class="xref-unresolved">Async_kernel__Types.Deferred.t</span></span></code></div><div><p><code>at time</code> returns a deferred <code>d</code> that will become determined as soon as possible after <code>time</code></p></div></div><div><div class="spec value" id="val-after" class="anchored"><a href="#val-after" class="anchor"></a><code><span class="keyword">val</span> after : <a href="Time/Span/index.html#type-t">Time.Span.t</a> <span>&#45;&gt;</span> <span>unit <span class="xref-unresolved">Async_kernel__Types.Deferred.t</span></span></code></div><div><p><code>after</code> is like <code>at</code>, except that one specifies a time span rather than an absolute time. If you set up a lot of <code>after</code> events at the beginning of your program they will trigger at the same time. Use <code>Time.Span.randomize</code> to even them out.</p></div></div><div><div class="spec value" id="val-with_timeout" class="anchored"><a href="#val-with_timeout" class="anchor"></a><code><span class="keyword">val</span> with_timeout : <a href="Time/Span/index.html#type-t">Time.Span.t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Async_kernel__Types.Deferred.t</span></span> <span>&#45;&gt;</span> <span><span>[ `Timeout <span><span>| `Result</span> of <span class="type-var">'a</span></span> ]</span> <span class="xref-unresolved">Async_kernel__Types.Deferred.t</span></span></code></div><div><p><code>with_timeout span d</code> returns a deferred that will become determined after either <code>span</code> elapses or <code>d</code> is determined, returning either <code>`Timeout</code> or <code>`Result</code> depending on which one succeeded first. At the time the returned deferred becomes determined, both things may have happened, in which case <code>`Result</code> is given preference.</p></div></div><div><div class="spec module" id="module-Event" class="anchored"><a href="#module-Event" class="anchor"></a><code><span class="keyword">module</span> <a href="Event/index.html">Event</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><p>Events provide variants of <code>run_at</code> and <code>run_after</code> with the ability to abort or reschedule an event that hasn't yet happened. Once an event happens or is aborted, Async doesn't use any space for tracking it.</p></div></div><div><div class="spec value" id="val-at_varying_intervals" class="anchored"><a href="#val-at_varying_intervals" class="anchor"></a><code><span class="keyword">val</span> at_varying_intervals : <span>?&#8288;stop:<span>unit <span class="xref-unresolved">Async_kernel__Types.Deferred.t</span></span></span> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <a href="Time/Span/index.html#type-t">Time.Span.t</a>)</span> <span>&#45;&gt;</span> <span>unit <a href="../../Tail/Stream/index.html#type-t">Tail.Stream.t</a></span></code></div><div><p><code>at_varying_intervals f ?stop</code> returns a stream whose next element becomes determined by calling <code>f ()</code> and waiting for that amount of time, and then looping to determine subsequent elements. The stream will end after <code>stop</code> becomes determined.</p></div></div><div><div class="spec value" id="val-at_intervals" class="anchored"><a href="#val-at_intervals" class="anchor"></a><code><span class="keyword">val</span> at_intervals : <span>?&#8288;start:<a href="Time/index.html#type-t">Time.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;stop:<span>unit <span class="xref-unresolved">Async_kernel__Types.Deferred.t</span></span></span> <span>&#45;&gt;</span> <a href="Time/Span/index.html#type-t">Time.Span.t</a> <span>&#45;&gt;</span> <span>unit <a href="../../Tail/Stream/index.html#type-t">Tail.Stream.t</a></span></code></div><div><p><code>at_intervals interval ?start ?stop</code> returns a stream whose elements will become determined at nonnegative integer multiples of <code>interval</code> after the <code>start</code> time, until <code>stop</code> becomes determined:</p><pre>        start + 0 * interval
        start + 1 * interval
        start + 2 * interval
        start + 3 * interval
        ...</pre><p>Note that only elements that are strictly in the future ever become determined. In particular, if <code>start</code> is not in the future, or <code>start</code> is not provided, then there will be no element before the <code>interval</code> has passed.</p><p>If the interval is too small or the CPU is too loaded, <code>at_intervals</code> will skip until the next upcoming multiple of <code>interval</code> after <code>start</code>.</p></div></div><div><div class="spec value" id="val-every'" class="anchored"><a href="#val-every'" class="anchor"></a><code><span class="keyword">val</span> every' : <span>?&#8288;start:<span>unit <span class="xref-unresolved">Async_kernel__Types.Deferred.t</span></span></span> <span>&#45;&gt;</span> <span>?&#8288;stop:<span>unit <span class="xref-unresolved">Async_kernel__Types.Deferred.t</span></span></span> <span>&#45;&gt;</span> <span>?&#8288;continue_on_error:bool</span> <span>&#45;&gt;</span> <span>?&#8288;finished:<span>unit <a href="../../Ivar/index.html#type-t">Ivar.t</a></span></span> <span>&#45;&gt;</span> <a href="Time/Span/index.html#type-t">Time.Span.t</a> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <span>unit <span class="xref-unresolved">Async_kernel__Types.Deferred.t</span></span>)</span> <span>&#45;&gt;</span> unit</code></div><div><p><code>every' ?start ?stop span f</code> runs <code>f ()</code> every <code>span</code> amount of time starting when <code>start</code> becomes determined and stopping when <code>stop</code> becomes determined. <code>every</code> waits until the result of <code>f ()</code> becomes determined before waiting for the next <code>span</code>.</p><p>It is guaranteed that if <code>stop</code> becomes determined, even during evaluation of <code>f</code>, then <code>f</code> will not be called again by a subsequent iteration of the loop.</p><p>It is an error for <code>span</code> to be nonpositive.</p><p>With <code>~continue_on_error:true</code>, when <code>f</code> asynchronously raises, iteration continues. With <code>~continue_on_error:false</code>, if <code>f</code> asynchronously raises, then iteration only continues when the result of <code>f</code> becomes determined.</p><p>Exceptions raised by <code>f</code> are always sent to monitor in effect when <code>every'</code> was called, even with <code>~continue_on_error:true</code>.</p><p>If <code>finished</code> is supplied, <code>every'</code> will fill it once all of the following become determined: <code>start</code>, <code>stop</code>, and the result of the final call to <code>f</code>.</p></div></div><div><div class="spec value" id="val-every" class="anchored"><a href="#val-every" class="anchor"></a><code><span class="keyword">val</span> every : <span>?&#8288;start:<span>unit <span class="xref-unresolved">Async_kernel__Types.Deferred.t</span></span></span> <span>&#45;&gt;</span> <span>?&#8288;stop:<span>unit <span class="xref-unresolved">Async_kernel__Types.Deferred.t</span></span></span> <span>&#45;&gt;</span> <span>?&#8288;continue_on_error:bool</span> <span>&#45;&gt;</span> <a href="Time/Span/index.html#type-t">Time.Span.t</a> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></div><div><p><code>every ?start ?stop span f</code> is <code>every' ?start ?stop span (fun () -&gt; f (); return ())</code>.</p></div></div><div><div class="spec value" id="val-run_at_intervals'" class="anchored"><a href="#val-run_at_intervals'" class="anchor"></a><code><span class="keyword">val</span> run_at_intervals' : <span>?&#8288;start:<a href="Time/index.html#type-t">Time.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;stop:<span>unit <span class="xref-unresolved">Async_kernel__Types.Deferred.t</span></span></span> <span>&#45;&gt;</span> <span>?&#8288;continue_on_error:bool</span> <span>&#45;&gt;</span> <a href="Time/Span/index.html#type-t">Time.Span.t</a> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <span>unit <span class="xref-unresolved">Async_kernel__Types.Deferred.t</span></span>)</span> <span>&#45;&gt;</span> unit</code></div><div><p><code>run_at_intervals' ?start ?stop span f</code> runs <code>f()</code> at increments of <code>start + i *
      span</code> for nonnegative integers <code>i</code>, until <code>stop</code> becomes determined. If the result of <code>f</code> is not determined fast enough then the next interval(s) are skipped so that there are never multiple concurrent invocations of <code>f</code> in flight.</p><p>Exceptions raised by <code>f</code> are always sent to monitor in effect when <code>run_at_intervals'</code> was called, even with <code>~continue_on_error:true</code>.</p></div></div><div><div class="spec value" id="val-run_at_intervals" class="anchored"><a href="#val-run_at_intervals" class="anchor"></a><code><span class="keyword">val</span> run_at_intervals : <span>?&#8288;start:<a href="Time/index.html#type-t">Time.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;stop:<span>unit <span class="xref-unresolved">Async_kernel__Types.Deferred.t</span></span></span> <span>&#45;&gt;</span> <span>?&#8288;continue_on_error:bool</span> <span>&#45;&gt;</span> <a href="Time/Span/index.html#type-t">Time.Span.t</a> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></div><div><p><code>run_at_intervals ?start ?stop ?continue_on_error span f</code> is equivalent to:</p><pre><code>run_at_intervals' ?start ?stop ?continue_on_error span
  (fun () -&gt; f (); return ()) </code></pre></div></div></div></body></html>