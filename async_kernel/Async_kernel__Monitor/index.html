<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Async_kernel__Monitor (async_kernel.Async_kernel__Monitor)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">async_kernel</a> &#x00BB; Async_kernel__Monitor</nav><header><h1>Module <code>Async_kernel__Monitor</code></h1><p>The part of the <a href="../Async_kernel/Execution_context/index.html"><code>Execution_context</code></a> that determines what to do when there is an unhandled exception.</p><p>Every Async computation runs within the context of some monitor, which, when the computation is running, is referred to as the &quot;current&quot; monitor. Monitors are arranged in a tree -- when a new monitor is created, it is a child of the current monitor.</p><p>If a computation raises an unhandled exception, the behavior depends on whether the current monitor is &quot;detached&quot; or &quot;attached&quot;. If the monitor has been &quot;detached&quot;, via one of the <code>detach*</code> functions, then whoever detached it is responsible for dealing with the exception. If the monitor is still attached, then the exception bubbles to monitor's parent. If an exception bubbles to the initial monitor, i.e., the root of the monitor tree, that prints an unhandled-exception message and calls exit 1.</p><h3 id="note-about-the-toplevel-monitor"><a href="#note-about-the-toplevel-monitor" class="anchor"></a>Note about the toplevel monitor</h3><p>It is important to note that in the toplevel monitor, exceptions will only be caught in the Async part of a computation. For example, in:</p><pre><code>upon (f ()) g </code></pre><p>if <code>f</code> raises, the exception will not go to a monitor; it will go to the next caml exception handler on the stack. Any exceptions raised by <code>g</code> will be caught by the scheduler and propagated to the toplevel monitor. Because of this it is advised to always use <code>Scheduler.schedule</code> or <code>Scheduler.within</code>. For example:</p><pre><code>Scheduler.within (fun () -&gt; upon (f ()) g) </code></pre><p>This code will catch an exception in either <code>f</code> or <code>g</code>, and propagate it to the monitor.</p><p>This is only relevant to the toplevel monitor because if you create another monitor and you wish to run code within it you have no choice but to use <code>Scheduler.within</code>. <code>try_with</code> creates its own monitor and uses <code>Scheduler.within</code>, so it does not have this problem.</p></header><div class="content"></div></body></html>