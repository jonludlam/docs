<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Cstruct (cstruct.Cstruct)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> – <a href="../index.html">cstruct</a> &#x00BB; Cstruct</nav><header><h1>Module <code>Cstruct</code></h1><p>Manipulate external memory buffers as C-like structures.</p><p>Cstruct is a library and ppx rewriter to make it easier to access C-like structures directly from OCaml. It supports both reading and writing to these memory buffers, and they are accessed via the <code>Bigarray</code> module.</p><p>The library interface below is intended to be used in conjunction with the ppx rewriter that is also supplied with this library (in the <code>cstruct-ppx</code> ocamlfind package).</p><p>An example description for the pcap packet format is:</p><pre><code>[%%cstruct
type pcap_header = {
  magic_number:  uint32_t; (* magic number *)
  version_major: uint16_t; (* major version number *)
  version_minor: uint16_t; (* minor version number *)
  thiszone:      uint32_t; (* GMT to local correction *)
  sigfigs:       uint32_t; (* accuracy of timestamps *)
  snaplen:       uint32_t; (* max length of captured packets, in octets *)
  network:       uint32_t; (* data link type *)
} [@@little_endian]
]
[%%cstruct
type pcap_packet = {
  ts_sec:   uint32_t; (* timestamp seconds *)
  ts_usec:  uint32_t; (* timestamp microseconds *)
  incl_len: uint32_t; (* number of octets of packet saved in file *)
  orig_len: uint32_t; (* actual length of packet *)
} [@@little_endian]
]
[%%cstruct
type ethernet = {
  dst:       uint8_t;  [@len 6];
  src:       uint8_t;  [@len 6];
  ethertype: uint16_t;
} [@@big_endian]
]
[%%cstruct
type ipv4 = {
  hlen_version: uint8_t;
  tos:          uint8_t;
  len:          uint16_t;
  id:           uint16_t;
  off:          uint16_t;
  ttl:          uint8_t;
  proto:        uint8_t;
  csum:         uint16_t;
  src:          uint8_t;  [@len 4];
  dst:          uint8_t;  [@len 4]
} [@@big_endian]
]</code></pre><p>These will expand to get and set functions for every field, with types appropriate to the particular definition. For instance:</p><pre><code>val get_pcap_packet_ts_sec : Cstruct.t -&gt; Cstruct.uint32
val set_pcap_packet_ts_sec : Cstruct.t -&gt; Cstruct.uint32 -&gt; unit
val get_pcap_packet_ts_usec : Cstruct.t -&gt; Cstruct.uint32
val set_pcap_packet_ts_usec : Cstruct.t -&gt; Cstruct.uint32 -&gt; unit
val get_pcap_packet_incl_len : Cstruct.t -&gt; Cstruct.uint32
val set_pcap_packet_incl_len : Cstruct.t -&gt; Cstruct.uint32 -&gt; unit
val get_pcap_packet_orig_len : Cstruct.t -&gt; Cstruct.uint32
val set_pcap_packet_orig_len : Cstruct.t -&gt; Cstruct.uint32 -&gt; unit
val hexdump_pcap_packet_to_buffer : Buffer.t -&gt; Cstruct.t -&gt; unit</code></pre><p>The buffers generate a different set of functions. For the <code>ethernet</code> definitions, we have:</p><pre><code>val sizeof_ethernet : int
val get_ethernet_dst : Cstruct.t -&gt; Cstruct.t
val copy_ethernet_dst : Cstruct.t -&gt; string
val set_ethernet_dst : string -&gt; int -&gt; Cstruct.t -&gt; unit
val blit_ethernet_dst : Cstruct.t -&gt; int -&gt; Cstruct.t -&gt; unit
val get_ethernet_src : Cstruct.t -&gt; Cstruct.t
val copy_ethernet_src : Cstruct.t -&gt; string</code></pre><p>You can also declare C-like enums:</p><pre><code>[%%cenum
type foo32 =
  | ONE32
  | TWO32     [@id 0xfffffffel]
  | THREE32
[@@uint32_t]
]
[%%cenum
type bar16 =
  | ONE  [@id 1]
  | TWO
  | FOUR [@id 4
  | FIVE
[@@uint16_t]
]</code></pre><p>This generates signatures of the form:</p><pre><code>type foo32 = | ONE32 | TWO32 | THREE32
val int_to_foo32 : int32 -&gt; foo32 option
val foo32_to_int : foo32 -&gt; int32
val foo32_to_string : foo32 -&gt; string
val string_to_foo32 : string -&gt; foo32 option
type bar16 = | ONE | TWO | FOUR | FIVE
val int_to_bar16 : int -&gt; bar16 option
val bar16_to_int : bar16 -&gt; int
val bar16_to_string : bar16 -&gt; string
val string_to_bar16 : string -&gt; bar16 option</code></pre></header><nav class="toc"><ul><li><a href="#base-types">Base types</a></li><li><a href="#creation-and-conversion">Creation and conversion</a></li><li><a href="#comparison">Comparison</a></li><li><a href="#getters-and-setters">Getters and Setters</a></li><li><a href="#debugging">Debugging</a></li><li><a href="#list-of-buffers">List of buffers</a></li><li><a href="#iterations">Iterations</a></li></ul></nav><div class="content"><h3 id="base-types"><a href="#base-types" class="anchor"></a>Base types</h3><div><div class="spec type" id="type-buffer" class="anchored"><a href="#type-buffer" class="anchor"></a><code><span class="keyword">type</span> buffer = <span><span>(char, <a href="../../bigarray-compat/Bigarray_compat/index.html#type-int8_unsigned_elt">Bigarray_compat.int8_unsigned_elt</a>, <a href="../../bigarray-compat/Bigarray_compat/index.html#type-c_layout">Bigarray_compat.c_layout</a>)</span> <a href="../../bigarray-compat/Bigarray_compat/Array1/index.html#type-t">Bigarray_compat.Array1.t</a></span></code></div><div><p>Type of a buffer. A cstruct is composed of an underlying buffer and position/length within this buffer.</p></div></div><div><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t = <span class="keyword">private</span> {</code><table><tr id="type-t.buffer" class="anchored"><td class="def record field"><a href="#type-t.buffer" class="anchor"></a><code>buffer : <a href="index.html#type-buffer">buffer</a>;</code></td></tr><tr id="type-t.off" class="anchored"><td class="def record field"><a href="#type-t.off" class="anchor"></a><code>off : int;</code></td></tr><tr id="type-t.len" class="anchored"><td class="def record field"><a href="#type-t.len" class="anchor"></a><code>len : int;</code></td></tr></table><code>}</code></div><div><p>Type of a cstruct.</p></div></div><div><div class="spec type" id="type-byte" class="anchored"><a href="#type-byte" class="anchor"></a><code><span class="keyword">type</span> byte = char</code></div><div><p>A single byte type</p></div></div><div><div class="spec value" id="val-byte" class="anchored"><a href="#val-byte" class="anchor"></a><code><span class="keyword">val</span> byte : int <span>&#45;&gt;</span> <a href="index.html#type-byte">byte</a></code></div><div><p><code>byte v</code> convert <code>v</code> to a single byte.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>v</code> is negative or greater than 255.</p></dd></dl></div></div><div><div class="spec type" id="type-uint8" class="anchored"><a href="#type-uint8" class="anchor"></a><code><span class="keyword">type</span> uint8 = int</code></div><div><p>8-bit unsigned integer. The representation is currently an unboxed OCaml integer.</p></div></div><div><div class="spec type" id="type-uint16" class="anchored"><a href="#type-uint16" class="anchor"></a><code><span class="keyword">type</span> uint16 = int</code></div><div><p>16-bit unsigned integer. The representation is currently an unboxed OCaml integer.</p></div></div><div><div class="spec type" id="type-uint32" class="anchored"><a href="#type-uint32" class="anchor"></a><code><span class="keyword">type</span> uint32 = int32</code></div><div><p>32-bit unsigned integer. The representation is currently a boxed OCaml int32.</p></div></div><div><div class="spec type" id="type-uint64" class="anchored"><a href="#type-uint64" class="anchor"></a><code><span class="keyword">type</span> uint64 = int64</code></div><div><p>64-bit unsigned integer. The representation is currently a boxed OCaml int64.</p></div></div><h3 id="creation-and-conversion"><a href="#creation-and-conversion" class="anchor"></a>Creation and conversion</h3><div><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <a href="index.html#type-t">t</a></code></div><div><p><code>empty</code> is the cstruct of length 0.</p></div></div><div><div class="spec value" id="val-of_bigarray" class="anchored"><a href="#val-of_bigarray" class="anchor"></a><code><span class="keyword">val</span> of_bigarray : <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> <a href="index.html#type-buffer">buffer</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></div><div><p><code>of_bigarray ~off ~len b</code> is the cstruct contained in <code>b</code> starting at <code>off</code>, of length <code>len</code>.</p></div></div><div><div class="spec value" id="val-to_bigarray" class="anchored"><a href="#val-to_bigarray" class="anchor"></a><code><span class="keyword">val</span> to_bigarray : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-buffer">buffer</a></code></div><div><p><code>to_bigarray t</code> converts a <a href="index.html#type-t"><code>t</code></a> into a <a href="index.html#type-t.buffer"><code>buffer</code></a> Bigarray, using the Bigarray slicing to allocate a fresh array that preserves sharing of the underlying buffer.</p></div></div><div><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></div><div><p><code>create len</code> is a fresh cstruct of size <code>len</code> with an offset of 0, filled with zero bytes.</p></div></div><div><div class="spec value" id="val-create_unsafe" class="anchored"><a href="#val-create_unsafe" class="anchor"></a><code><span class="keyword">val</span> create_unsafe : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></div><div><p><code>create_unsafe len</code> is a cstruct of size <code>len</code> with an offset of 0.</p><p>Note that the returned cstruct will contain arbitrary data, likely including the contents of previously-deallocated cstructs.</p><p>Beware!</p><p>Forgetting to replace this data could cause your application to leak sensitive information.</p></div></div><div><div class="spec value" id="val-of_string" class="anchored"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : <span>?&#8288;allocator:<span>(int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></div><div><p><code>of_string ~allocator ~off ~len str</code> is the cstruct representation of <code>str</code> slice located at <code>off</code> offset and of <code>len</code> length, with the underlying buffer allocated by <code>alloc</code>. If <code>allocator</code> is not provided, <code>create</code> is used.</p></div></div><div><div class="spec value" id="val-of_bytes" class="anchored"><a href="#val-of_bytes" class="anchor"></a><code><span class="keyword">val</span> of_bytes : <span>?&#8288;allocator:<span>(int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;off:int</span> <span>&#45;&gt;</span> <span>?&#8288;len:int</span> <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></div><div><p><code>of_bytes ~allocator byt</code> is the cstruct representation of <code>byt</code> slice located at <code>off</code> offset and of <code>len</code> length, with the underlying buffer allocated by <code>alloc</code>. If <code>allocator</code> is not provided, <code>create</code> is used.</p></div></div><div><div class="spec value" id="val-of_hex" class="anchored"><a href="#val-of_hex" class="anchor"></a><code><span class="keyword">val</span> of_hex : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></div><div><p><code>of_hex str</code> is the cstruct <code>cs</code>. Every pair of hex-encoded characters in <code>str</code> are converted to one byte in <code>cs</code>. Whitespaces (space, newline, tab, carriage return) in <code>str</code> are skipped. The resulting cstruct is exactly half the size of the non-skipped characters of <code>str</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the input string contains invalid characters or has an odd numbers of non-whitespace characters.</p></dd></dl></div></div><h3 id="comparison"><a href="#comparison" class="anchor"></a>Comparison</h3><div><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></div><div><p><code>equal t1 t2</code> is <code>true</code> iff <code>t1</code> and <code>t2</code> correspond to the same sequence of bytes.</p></div></div><div><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></div><div><p><code>compare t1 t2</code> gives an unspecified total ordering over <a href="index.html#type-t"><code>t</code></a>.</p></div></div><h3 id="getters-and-setters"><a href="#getters-and-setters" class="anchor"></a>Getters and Setters</h3><div><div class="spec value" id="val-byte_to_int" class="anchored"><a href="#val-byte_to_int" class="anchor"></a><code><span class="keyword">val</span> byte_to_int : <a href="index.html#type-byte">byte</a> <span>&#45;&gt;</span> int</code></div><div><p>Convert a byte to an integer</p></div></div><div><div class="spec value" id="val-check_bounds" class="anchored"><a href="#val-check_bounds" class="anchor"></a><code><span class="keyword">val</span> check_bounds : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool</code></div><div><p><code>check_bounds cstr len</code> is <code>true</code> if <code>len</code> is a non-negative integer and <code>cstr.buffer</code>'s size is greater or equal than <code>len</code> <code>false</code> otherwise.</p></div></div><div><div class="spec value" id="val-check_alignment" class="anchored"><a href="#val-check_alignment" class="anchor"></a><code><span class="keyword">val</span> check_alignment : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool</code></div><div><p><code>check_alignment cstr alignment</code> is <code>true</code> if the first byte stored within <code>cstr</code> is at a memory address where <code>address mod alignment = 0</code>, <code>false</code> otherwise. Typical uses are to check a buffer is aligned to a page or disk sector boundary.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>alignment</code> is not a positive integer.</p></dd></dl></div></div><div><div class="spec value" id="val-get_char" class="anchored"><a href="#val-get_char" class="anchor"></a><code><span class="keyword">val</span> get_char : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char</code></div><div><p><code>get_char t off</code> returns the character contained in the cstruct at offset <code>off</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the offset exceeds cstruct length.</p></dd></dl></div></div><div><div class="spec value" id="val-get_uint8" class="anchored"><a href="#val-get_uint8" class="anchor"></a><code><span class="keyword">val</span> get_uint8 : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-uint8">uint8</a></code></div><div><p><code>get_uint8 t off</code> returns the byte contained in the cstruct at offset <code>off</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the offset exceeds cstruct length.</p></dd></dl></div></div><div><div class="spec value" id="val-set_char" class="anchored"><a href="#val-set_char" class="anchor"></a><code><span class="keyword">val</span> set_char : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit</code></div><div><p><code>set_char t off c</code> sets the byte contained in the cstruct at offset <code>off</code> to character <code>c</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the offset exceeds cstruct length.</p></dd></dl></div></div><div><div class="spec value" id="val-set_uint8" class="anchored"><a href="#val-set_uint8" class="anchor"></a><code><span class="keyword">val</span> set_uint8 : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-uint8">uint8</a> <span>&#45;&gt;</span> unit</code></div><div><p><code>set_uint8 t off c</code> sets the byte contained in the cstruct at offset <code>off</code> to byte <code>c</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the offset exceeds cstruct length.</p></dd></dl></div></div><div><div class="spec value" id="val-sub" class="anchored"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val</span> sub : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></div><div><p><code>sub cstr off len</code> is <code>{ t with off = t.off + off; len }</code></p><dl><dt>raises Invalid_argument</dt><dd><p>if the offset exceeds cstruct length.</p></dd></dl></div></div><div><div class="spec value" id="val-shift" class="anchored"><a href="#val-shift" class="anchor"></a><code><span class="keyword">val</span> shift : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></div><div><p><code>shift cstr len</code> is <code>{ cstr with off=t.off+len; len=t.len-len }</code></p><dl><dt>raises Invalid_argument</dt><dd><p>if the offset exceeds cstruct length.</p></dd></dl></div></div><div><div class="spec value" id="val-copy" class="anchored"><a href="#val-copy" class="anchor"></a><code><span class="keyword">val</span> copy : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> string</code></div><div><p><code>copy cstr off len</code> is the string representation of the segment of <code>t</code> starting at <code>off</code> of size <code>len</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>off</code> and <code>len</code> do not designate a valid segment of <code>t</code>.</p></dd></dl></div></div><div><div class="spec value" id="val-blit" class="anchored"><a href="#val-blit" class="anchor"></a><code><span class="keyword">val</span> blit : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></div><div><p><code>blit src srcoff dst dstoff len</code> copies <code>len</code> characters from cstruct <code>src</code>, starting at index <code>srcoff</code>, to cstruct <code>dst</code>, starting at index <code>dstoff</code>. It works correctly even if <code>src</code> and <code>dst</code> are the same string, and the source and destination intervals overlap.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>srcoff</code> and <code>len</code> do not designate a valid segment of <code>src</code>, or if <code>dstoff</code> and <code>len</code> do not designate a valid segment of <code>dst</code>.</p></dd></dl></div></div><div><div class="spec value" id="val-blit_from_string" class="anchored"><a href="#val-blit_from_string" class="anchor"></a><code><span class="keyword">val</span> blit_from_string : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></div><div><p><code>blit_from_string src srcoff dst dstoff len</code> copies <code>len</code> characters from string <code>src</code>, starting at index <code>srcoff</code>, to cstruct <code>dst</code>, starting at index <code>dstoff</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>srcoff</code> and <code>len</code> do not designate a valid substring of <code>src</code>, or if <code>dstoff</code> and <code>len</code> do not designate a valid segment of <code>dst</code>.</p></dd></dl></div></div><div><div class="spec value" id="val-blit_from_bytes" class="anchored"><a href="#val-blit_from_bytes" class="anchor"></a><code><span class="keyword">val</span> blit_from_bytes : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></div><div><p><code>blit_from_bytes src srcoff dst dstoff len</code> copies <code>len</code> characters from bytes <code>src</code>, starting at index <code>srcoff</code>, to cstruct <code>dst</code>, starting at index <code>dstoff</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>srcoff</code> and <code>len</code> do not designate a valid subsequence of <code>src</code>, or if <code>dstoff</code> and <code>len</code> do not designate a valid segment of <code>dst</code>.</p></dd></dl></div></div><div><div class="spec value" id="val-blit_to_bytes" class="anchored"><a href="#val-blit_to_bytes" class="anchor"></a><code><span class="keyword">val</span> blit_to_bytes : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></div><div><p><code>blit_to_bytes src srcoff dst dstoff len</code> copies <code>len</code> characters from cstruct <code>src</code>, starting at index <code>srcoff</code>, to the <code>dst</code> buffer, starting at index <code>dstoff</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>srcoff</code> and <code>len</code> do not designate a valid segment of <code>src</code>, or if <code>dstoff</code> and <code>len</code> do not designate a valid segment of <code>dst</code>.</p></dd></dl></div></div><div><div class="spec value" id="val-blit_to_string" class="anchored"><a href="#val-blit_to_string" class="anchor"></a><code><span class="keyword">val</span> blit_to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></div><div><p><code>blit_to_string</code> is a deprecated alias of <a href="index.html#val-blit_to_bytes"><code>blit_to_bytes</code></a>.</p></div></div><div><div class="spec value" id="val-memset" class="anchored"><a href="#val-memset" class="anchor"></a><code><span class="keyword">val</span> memset : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></div><div><p><code>memset t x</code> sets all the bytes of <code>t</code> to <code>x land 0xff</code>.</p></div></div><div><div class="spec value" id="val-len" class="anchored"><a href="#val-len" class="anchor"></a><code><span class="keyword">val</span> len : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></div><div><p>Returns the length of the current cstruct view. Note that this length is potentially smaller than the actual size of the underlying buffer, as the <code>sub</code> or <code>set_len</code> functions can construct a smaller view.</p></div></div><div><div class="spec value" id="val-set_len" class="anchored"><a href="#val-set_len" class="anchor"></a><code><span class="keyword">val</span> set_len : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></div><div><p><code>set_len t len</code> sets the length of the cstruct <code>t</code> to a new absolute value, and returns a fresh cstruct with these settings.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>len</code> exceeds the size of the buffer.</p></dd></dl></div></div><div><div class="spec value" id="val-add_len" class="anchored"><a href="#val-add_len" class="anchor"></a><code><span class="keyword">val</span> add_len : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></div><div><p><code>add_len t l</code> will add <code>l</code> bytes to the length of the buffer, and return a fresh cstruct with these settings.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>len</code> exceeds the size of the buffer.</p></dd></dl></div></div><div><div class="spec value" id="val-split" class="anchored"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : <span>?&#8288;start:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a></code></div><div><p><code>split ~start cstr len</code> is a tuple containing the cstruct extracted from <code>cstr</code> at offset <code>start</code> (default: 0) of length <code>len</code> as first element, and the rest of <code>cstr</code> as second element.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>start</code> exceeds the cstruct length, or if there is a bounds violation of the cstruct via <code>len+start</code>.</p></dd></dl></div></div><div><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></div><div><p><code>to_string t</code> will allocate a fresh OCaml <code>string</code> and copy the contents of the cstruct into it, and return that string copy.</p></div></div><div><div class="spec value" id="val-to_bytes" class="anchored"><a href="#val-to_bytes" class="anchor"></a><code><span class="keyword">val</span> to_bytes : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bytes</code></div><div><p><code>to_bytes t</code> will allocate a fresh OCaml <code>bytes</code> and copy the contents of the cstruct into it, and return that byte copy.</p></div></div><h3 id="debugging"><a href="#debugging" class="anchor"></a>Debugging</h3><div><div class="spec value" id="val-hexdump" class="anchored"><a href="#val-hexdump" class="anchor"></a><code><span class="keyword">val</span> hexdump : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></div><div><p>When the going gets tough, the tough hexdump their cstructs and peer at it until the bug disappears. This will directly prettyprint the contents of the cstruct to the standard output.</p></div></div><div><div class="spec value" id="val-hexdump_to_buffer" class="anchored"><a href="#val-hexdump_to_buffer" class="anchor"></a><code><span class="keyword">val</span> hexdump_to_buffer : <a href="../../ocaml/Stdlib/Buffer/index.html#type-t">Stdlib.Buffer.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></div><div><p><code>hexdump_to_buffer buf c</code> will append the pretty-printed hexdump of the cstruct <code>c</code> to the buffer <code>buf</code>.</p></div></div><div><div class="spec value" id="val-hexdump_pp" class="anchored"><a href="#val-hexdump_pp" class="anchor"></a><code><span class="keyword">val</span> hexdump_pp : <a href="../../ocaml/Stdlib/Format/index.html#type-formatter">Stdlib.Format.formatter</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></div><div><p><code>hexdump_pp f c</code> pretty-prints a hexdump of <code>c</code> to <code>f</code>.</p></div></div><div><div class="spec value" id="val-debug" class="anchored"><a href="#val-debug" class="anchor"></a><code><span class="keyword">val</span> debug : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></div><div><p><code>debug t</code> will print out the internal details of a cstruct such as its base offset and the length, and raise an assertion failure if invariants have been violated. Not intended for casual use.</p></div></div><div class="spec module" id="module-BE" class="anchored"><a href="#module-BE" class="anchor"></a><code><span class="keyword">module</span> <a href="BE/index.html">BE</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-LE" class="anchored"><a href="#module-LE" class="anchor"></a><code><span class="keyword">module</span> <a href="LE/index.html">LE</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><h3 id="list-of-buffers"><a href="#list-of-buffers" class="anchor"></a>List of buffers</h3><div><div class="spec value" id="val-lenv" class="anchored"><a href="#val-lenv" class="anchor"></a><code><span class="keyword">val</span> lenv : <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> int</code></div><div><p><code>lenv cstrs</code> is the combined length of all cstructs in <code>cstrs</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if computing the sum overflows.</p></dd></dl></div></div><div><div class="spec value" id="val-copyv" class="anchored"><a href="#val-copyv" class="anchor"></a><code><span class="keyword">val</span> copyv : <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> string</code></div><div><p><code>copyv cstrs</code> is the string representation of the concatenation of all cstructs in <code>cstrs</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the length of the result would exceed <code>Sys.max_string_length</code>.</p></dd></dl></div></div><div><div class="spec value" id="val-fillv" class="anchored"><a href="#val-fillv" class="anchor"></a><code><span class="keyword">val</span> fillv : <span>src:<span><a href="index.html#type-t">t</a> list</span></span> <span>&#45;&gt;</span> <span>dst:<a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int * <span><a href="index.html#type-t">t</a> list</span></code></div><div><p><code>fillv ~src ~dst</code> copies from <code>src</code> to <code>dst</code> until <code>src</code> is exhausted or <code>dst</code> is full. Returns the number of bytes copied and the remaining data from <code>src</code>, if any. This is useful if you want buffer data into fixed-sized chunks.</p></div></div><h3 id="iterations"><a href="#iterations" class="anchor"></a>Iterations</h3><div><div class="spec type" id="type-iter" class="anchored"><a href="#type-iter" class="anchor"></a><code><span class="keyword">type</span> <span>'a iter</span> = unit <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></div><div><p>Type of an iterator.</p></div></div><div><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>int option</span>)</span> <span>&#45;&gt;</span> <span>(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-iter">iter</a></span></code></div><div><p><code>iter lenf of_cstr cstr</code> is an iterator over <code>cstr</code> that returns elements of size <code>lenf cstr</code> and type <code>of_cstr cstr</code>.</p></div></div><div><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-iter">iter</a></span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></div><div><p><code>fold f iter acc</code> is <code>(f iterN accN ... (f iter acc)...)</code>.</p></div></div><div><div class="spec value" id="val-append" class="anchored"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></div><div><p><code>append t1 t2</code> is the concatenation <code>t1 || t2</code>.</p></div></div><div><div class="spec value" id="val-concat" class="anchored"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></div><div><p><code>concat ts</code> is the concatenation of all the <code>ts</code>. It is not guaranteed that * the result is a newly created <code>t</code> in the zero- and one-element cases.</p></div></div><div><div class="spec value" id="val-rev" class="anchored"><a href="#val-rev" class="anchor"></a><code><span class="keyword">val</span> rev : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></div><div><p><code>rev t</code> is <code>t</code> in reverse order. The return value is a freshly allocated cstruct, and the argument is not modified.</p></div></div></div></body></html>