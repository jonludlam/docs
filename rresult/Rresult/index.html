<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Rresult (rresult.Rresult)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> – <a href="../index.html">rresult</a> &#x00BB; Rresult</nav><header><h1>Module <code>Rresult</code></h1><p>Result value combinators.</p><p><code>Rresult</code> is a module for handling computation results and errors in an explicit and declarative manner without resorting to exceptions. It defines a <a href="../../result/result/index.html"><code>result</code></a> type equal to OCaml 4.03's <code>result</code> type and <span class="xref-unresolved">combinators</span> to operate on these values.</p><p>Open the module to use it, this defines the <a href="../../result/result/index.html">result type</a>, the <code>R</code>.Infix operators <code>R</code> in your scope.</p><p>Consult <span class="xref-unresolved">usage guidelines</span> for the type.</p><p><em>v0.6.0 - <a href="http://erratique.ch/software/rresult">homepage</a></em></p></header><nav class="toc"><ul><li><a href="#results">Results</a></li><li><a href="#usage">Usage design guidelines</a><ul><li><a href="#error-messages">Error messages</a></li><li><a href="#custom-error-types">Custom error types</a></li></ul></li></ul></nav><div class="content"><h2 id="results"><a href="#results" class="anchor"></a>Results</h2><div><div class="spec type" id="type-result" class="anchored"><a href="#type-result" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) result</span> = <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../../result/Result/index.html#type-result">Result.result</a></span> = </code><table><tr id="type-result.Ok" class="anchored"><td class="def variant constructor"><a href="#type-result.Ok" class="anchor"></a><code>| <span class="constructor">Ok</span> <span class="keyword">of</span> <span class="type-var">'a</span></code></td></tr><tr id="type-result.Error" class="anchored"><td class="def variant constructor"><a href="#type-result.Error" class="anchor"></a><code>| <span class="constructor">Error</span> <span class="keyword">of</span> <span class="type-var">'b</span></code></td></tr></table></div><div><p>The type for results.</p></div></div><div><div class="spec value" id="val-(&gt;&gt;=)" class="anchored"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../../result/Result/index.html#type-result">Result.result</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'c</span>, <span class="type-var">'b</span>)</span> <a href="../../result/Result/index.html#type-result">Result.result</a></span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'c</span>, <span class="type-var">'b</span>)</span> <a href="../../result/Result/index.html#type-result">Result.result</a></span></code></div><div><p><code>(&gt;&gt;=)</code> is <code>R</code>.( &gt;&gt;= ).</p></div></div><div><div class="spec value" id="val-(&gt;&gt;|)" class="anchored"><a href="#val-(&gt;&gt;|)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;|) : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../../result/Result/index.html#type-result">Result.result</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'c</span>, <span class="type-var">'b</span>)</span> <a href="../../result/Result/index.html#type-result">Result.result</a></span></code></div><div><p><code>(&gt;&gt;|)</code> is <code>R</code>.( &gt;&gt;| ).</p></div></div><div><div class="spec module" id="module-R" class="anchored"><a href="#module-R" class="anchor"></a><code><span class="keyword">module</span> <a href="R/index.html">R</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><p>Result value combinators.</p></div></div><h2 id="usage"><a href="#usage" class="anchor"></a>Usage design guidelines</h2><aside><p>These are rough design guidelines, don't forget to think.</p></aside><h3 id="error-messages"><a href="#error-messages" class="anchor"></a>Error messages</h3><aside><p>Use <a href="index.html#msgs">error messages</a> if:</p><ol><li>Your error messages don't need to be localized, e.g. scripts, command line programs.</li><li>The errors don't need to be processed. They are just meant to be logged at certain point in your program.</li></ol><p>If the above doesn't hold and your errors need to be processed for localization or error recovery then use a custom error type in your result values.</p></aside><h3 id="custom-error-types"><a href="#custom-error-types" class="anchor"></a>Custom error types</h3><aside><p>If your module has specific errors then define an error type, and a result type that tags this error type with the library name (or any other tag that may make sense, see for example <a href="index.html#exn"><code>R:exn</code></a>) along with the following functions:</p><pre><code>module Mod : sig
  type error = ...
  type 'a result = ('a, [`Mod of error]) Rresult.result
  val pp_error : Format.formatter -&gt; [`Mod of error] -&gt; unit
  val open_error : 'a result -&gt; ('a, [&gt; `Mod of error]) Rresult.result
  val error_to_msg : 'a result -&gt; ('a, Rresult.R.msg) Rresult.result

  val f : ... -&gt; 'a result
end</code></pre><p>If your library has generic errors that may be useful in other context or shared among modules and to be composed together, then define your error type itself as being a variant and return these values without tagging them.</p><pre><code>module Mod : sig
  type error = [`Generic of ... | ... ]
  type 'a result = ('a, error) Rresult.result
  val pp_error : Format.formatter -&gt; error -&gt; unit
  val open_error : 'a result -&gt; ('a, [&gt; error]) Rresult.result
  val error_to_msg : 'a result -&gt; ('a, Rresult.R.msg) Rresult.result

  val f : ... -&gt; 'a result
end</code></pre><p>In the latter case it may still be useful to provide a function to tag these errors whenever they reach a certain point of the program. For this the following function could be added to <code>Mod</code>:</p><pre><code>val pack_error : 'a result -&gt;  ('a, [&gt; `Mod of error]) Rresult.result</code></pre><p>You should then provide the following functions aswell, so that the packed error composes well in the system:</p><pre><code>val pp_pack_error : Format.formatter -&gt; [ `Mod of error] -&gt; unit
val open_pack_error :  ('a, [ `Mod of error]) Rresult.result -&gt;
  ('a, [&gt; `Mod of error]) Rresult.result

val error_pack_to_msg : ('a, [ `Mod of error]) Rresult.result -&gt;
  ('a, Rresult.R.msg) Rresult.result</code></pre></aside></div></body></html>